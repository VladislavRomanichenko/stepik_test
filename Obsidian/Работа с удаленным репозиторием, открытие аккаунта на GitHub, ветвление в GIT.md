21.04.2023    18:32
Теги: #Git 
---
# ***Внутренние ссылки:***

---
# ***Внешние ссылки:***
[2.5 Основы Git - Работа с удалёнными репозиториями](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D0%BC%D0%B8)

---
# ***Заметка:***

# Команды 

`git clone https://github.com/kotBantik/mysuperproject1` _—_ клонирует удаленный репозиторий на локальную машину

`git remote add origin https://github.com/kotBantik/something.git` _—_ cвязывает наш локальный репозиторий с удаленным репозиторием   

`git push origin` _—_ отправляет коммиты на сервер

`git remote add origin HEAD` _—_ отправляет на сервер текущую ветку со всеми коммитами, которые мы сделали в ней.

# GitHub

## Начало работы с удаленным репозиторием

Напомним, что удаленный (внешний) репозиторий представляет собой версии нашего проекта, сохраненные на удаленном сервере. 

Когда мы подключаем удаленный репозиторий к своему локальному, то у нас появляются копии всех объектов удаленного репозитория (ветки, указатели и теги). Они сохраняются в локальной папке .git/refs/remotes/имя_удаленного_репозитория.

Например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main, где origin – это имя удаленного репозитория, а main – это название ветки. 

## Учимся создавать репозиторий на GitHub

После регистрации мы попадаем на главную страницу. На ней будут отображаться действия людей, на которых мы подпишемся и обновления в репозиториях, которые мы добавим в избранное. Чтобы создать свой репозиторий, нажмем на зеленую кнопку **New**
![[Pasted image 20230421183507.png]]
Откроется страница создания репозитория
![[Pasted image 20230421183513.png]]
**Поля** к заполнению:

- Repository name – имя репозитория, которое будет отображаться на странице нашего репозитория. Ограничений нет, но старайтесь давать как можно более содержательные имена своим репозиториям. Напишем, например, test111

- Description – описание, заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните это поле. Something to test, наверное, подойдет)))

- возможность выбора, будет ли репозиторий открытым, то есть доступным абсолютно всем пользователям GitHub, или закрытым, то есть доступным только вам и людям, которым вы предоставите доступ.

- последние три поля предлагают нам добавить README файл, .gitignore файл и выбрать лицензию для нашего проекта. Можем их проигнорировать. Или оставим возможность добавления README файла, в который потом можно поместить детальное описание проекта.

Жмем Create repository. После заполнения полей страница выглядит так:

![[Pasted image 20230421183841.png]]

GitHub автоматически создал первый коммит, добавив в него файл README.md:

![[Pasted image 20230421183854.png]]

## Как копировать к себе уже существующие удаленные репозитории?

### Часть I

 Ситуация 1.

У нас есть готовый код, который мы хотим выгрузить на удаленный репозиторий, чтобы другие разработчики смогли получить к нему доступ. Другими словами, нам надо добавить удаленный репозиторий к вашему локальному.

Для этого в Git есть команда `git remote add имя_репозитория URL_ссылка`, которая подключает удаленный репозиторий к нашему локальному под переданным именем. Переданное имя мы придумываем сами (обычно это origin), по нему впоследствии, мы будем обращаться к удаленному репозиторию. URL-ссылку мы берем, нажав на большую зеленую кнопку **Code** на странице репозитория на GitHub:

![[Pasted image 20230421183910.png]]

Нам предлагается выбрать одну из 3-х ссылок:

1) HTTP-ссылка

2) SSH-ссылка

3) GitHub CLI ссылка

Рассмотрим каждую.

#### 1. HTTP-ссылка

![[Pasted image 20230421183920.png]]

Раньше можно было подключаться по HTTP-ссылке, используя имя пользователя и пароль от аккаунта GitHub. Сейчас такой способ невозможен, при подключении по HTTP нужно использовать персональный токен.

##### Создание персонального токена доступа (personal access token)

1. После подтверждения почты в правом верхнем углу страницы кликаем на фотографию профиля и выбираем **Settings**:

![[Pasted image 20230421183930.png]]

2. Щелкаем и в самом конце выбираем **Developer setting.**

![[Pasted image 20230421183937.png]]

3. В Настройках разработчика выбираем **Tokens (classic)** и кликаем на **Generate new token**:

![[Pasted image 20230421183952.png]]

 4. Кликаем на **Generate new token (classic)**.

![[Pasted image 20230421184002.png]]

Может выскочить форма подтверждения доступа, в которую нужно ввести свой пароль
![[Pasted image 20230421184015.png]]
5. Почти готово, осталось пройтись по настройкам:

![[Pasted image 20230421184022.png]]

- назвать свой токен:
![[Pasted image 20230421184028.png]]
- выбрать срок его действия
![[Pasted image 20230421184034.png]]
- дать токену разрешения. Пользователь токена сможет выполнять с удаленным репозиторием только то, что мы укажем в этих разрешениях. Например, можем выбрать **repo,** если хотим использовать токен для доступа к репозиториям из командной строки. Если ничего не назначим здесь, то получим доступ только к общедоступной информации.

6. Нажмем **Generate token** (сгенерировать токен) и получим:
![[Pasted image 20230421184043.png]]
7. Обязательно скопируем токен в отдельный файл! В целях безопасности, как только мы уйдем со страницы создания токена, мы больше не сможем просмотреть этот токен.

Теперь, когда при первой загрузке изменений из удаленного репозитория, нас попросят ввести имя пользователя на GitHub и пароль, мы введем свой логин, а вместо пароля вставим этот токен. Действовать он будет ровно столько, сколько указали в Expiration.

#### 2. SSH-ссылка

![[Pasted image 20230421185047.png]]

Чтобы подключиться по SSH-ссылке, сначала надо у себя на компе сгенерировать SSH-ключи.

SSH-ключи состоят из двух — открытого (public) и закрытого (private) ключа. Открытый ключ мы отправляем на сервер, не переживаем за него, потому что без закрытого ключа он бесполезен. А вот закрытый ключ — это секретная часть, доступ к нему должен быть только у нас.

После создания пары ключей, нам нужно добавить закрытый ключ в SSH-агент. SSH-агент – это специальная программа для хранения и управления SSH-ключами. Она сохраняет пароль от файла с закрытым ключом и помогает удаленному серверу убедиться, что мы – владельцы закрытого ключа. Нам не надо будет при каждом подключении к удаленному серверу вводить пароль от файла с приватным ключом.

Как это работает:

Отправляем какую-то информацию на GitHub, который знает наш открытый ключ

GitHub по открытому ключу понимает, что это мы, и отправляет что-то в ответ

Мы расшифровываем этот ответ, потому что только у нас есть подходящий закрытый ключ

А чтобы подключиться к GitHub с помощью SSH-ключей, сначала нужно их создать, сам собой они не появятся. Но проверим, возможно, они были установлены раньше. Обычно они лежат в папке с названием `.ssh` — поэтому посмотрим, есть ли в ней что-то, с помощью команды в терминале:

`ls -al ~/.ssh`

Если в списке видим файлы с именами вроде `id_rsa.pub` и `id_rsa` значит SSH-ключ у нас уже есть. Если терминал ругается, что директории `~/.ssh` не существует, значит SSH-ключей нет. Сгенерируем)

1. Открываем Git Bash (если **Windows**) или терминал (если **Linux/MacOS**) и даем команду:

`ssh-keygen -t rsa -b 4096 -C "адрес почты, на которую мы регистрировались на гитхабе"`

Важно: имейл вводим в кавычках.

keygen — это инструмент генерации ключей, входит в набор инструментов командной строки SSH.

2. Нам предложат ввести путь к папке, в которой будет сохранен ключ, или выбрать папку для сохранения по умолчанию. Жмем **Enter**, чтобы выбрать директорию по умолчанию, или прописываем другую папку и тоже жмем **Enter**.

3. Добавим пароль, которым будет зашифрован ключ, а можем и не добавлять. Жмем **Enter**, чтобы оставить файл без пароля, либо введем пароль и жмем **Enter**.

Мы сгенерировали SSH-ключи, привязанные к нашей электронной почте. Теперь добавим их через SSH-агента, для чего сначала его запустим:

`` eval `ssh-agent -s` ``

Ждем в ответ надпись «Agent pid» и число — значит, все хорошо, мы запустили агента. Затем введем команду  `ssh-add путь_до_приватного_ключа`. Если мы оставили путь по умолчанию, то команда будет выглядеть так:

`ssh-add ~/.ssh/id_ed25519`

Теперь добавляем публичный ключ на GitHub:

- откроем файл с публичным ключом (он должен иметь расширение **.pub**). Если мы оставили путь по умолчанию, то наш ключ будет располагаться по адресу **~/.ssh/id_ed25519.pub**.

- скопируйте содержимое файла командой `clip`, переходим в настройки GitHub в раздел **SSH and GPG keys**

Чтобы скопировать в буфер обмена, перенаправляем вывод любой команды в xlip:

```bash
cat id_rsa.pub | xclip -selection clipboard
```

или короткая версия:

```bash
cat id_rsa.pub | xclip -sel clip
```

С помощью данной утилиты мы можем и вставить текст в терминал из буфера обмена. Для этого нужно указать команду xclip вместе с ключом -out (-o):

```bash
xclip -selection clipboard -out
```

или короткая версия:

```bash
xclip -sel clip -o
```

![[Pasted image 20230421185113.png]]

- нажимаем кнопку _New SSH key_

![[Pasted image 20230421185122.png]]

В поле _Title_ добавляем имя нового ключа (какое хотим), в поле _Key вставляем_ ключ, который скопировали командой  `clip`

![[Pasted image 20230421185128.png]]

Нажимаем кнопку _Add SSH key_ (если потребуется, вводим свой пароль от GitHub, чтобы подтвердить сохранение). Смотрим новый ключ в списке на странице [https://github. com/settings/keys](https://github.com/settings/keys)

Все. Можем безопасно работать с удаленным репозиторием, больше не нужно вводить логин и пароль при каждой загрузке или скачивании изменений из него.

**3. GitHub CLI ссылка**

![[Pasted image 20230421185134.png]]

Эта ссылка используется в клиенте GitHub (нужен для упрощения работы с Git), который можно поставить отдельно, но его возможности значительно ограничены по сравнению с консольным вариантом Git. Т.е. данную ссылку нужно использовать в специальной программе для компьютера с графическим **UI** от создателей GitHub.

#### Можно ли отключить удаленный репозиторий от локального?

Да, такую возможность дает команда `git remote remove имя_удаленного_репозитория`

Имя репозитория то, которое мы указывали в команде `git remote add`.

`git remote remove имя_удаленного_репозитория` не удалит удаленный репозиторий с сервера, она удалит только подключение нашего репозитория к удаленному.

#### Просмотр удаленных репозиториев

Чтобы просмотреть список всех подключенных удаленных репозиториев и получить информацию о каждом из них, мы используем команду `git remote show`, а если мы передадим имя удаленного репозитория, то получим всю информацию об этом репозитории:

`git remote show origin` — выведет информацию о репозитории origin.

### Часть II

#### Клонирование удаленного репозитория

Рассмотрим ситуацию 2 – клонирование удаленного репозитория к себе на компьютер, например, когда нам нужно поработать над уже существующим кодом

Операция клонирования создает на нашем компьютере точную копию удаленного репозитория. Она выполняется командой `git clone ссылка_на_удаленный_репозиторий`. Ссылку на удаленный репозиторий мы получаем, нажать на зеленую кнопку **Code** на главной странице репозитория на GitHub.

Клонирование по HTTPS-ссылке возможно вообще всегда, а по SSH – нет, если только владелец удаленного репозитория не передаст нам закрытый SSH-ключ от своей пары. Если мы настроили SSH в своем аккаунте, то можем легко клонировать **свои** репозитории и по HTTPS и по SSH. Но при попытке клонировать чужой репозиторий по SSH получим ошибку доступа.

Берем ссылку по HTTPS  и в терминале после команды `git clone` пропишем эту ссылку

`git clone https://github.com/kotBantik/my_super_project`

Произойдет следующее:

В папке, откуда мы запустили команду `git clone`, создается директория с именем репозитория. В нее копируется репозиторий, все его ветки и коммиты. Этот скопированный репозиторий – теперь наш локальный репозиторий. В него добавляется удаленный репозиторий с именем **origin** и ссылкой, которую мы передавали в **git clone**. Это избавляет нас от необходимости вручную писать `git remote add origin https://github.com/kotBantik/my_super_project`, как если бы мы создали пустой репозиторий с помощью `git init .`.

То есть,  мы используем имеющийся проект в качестве репозитория, после чего нам останется вручную загрузить изменения с удаленного репозитория командой **git pull**, которую мы рассмотрим далее по курсу.

Допустим, у нас на компьютере уже есть проект (папка, которая и будет репозиторием) something. Заходим в папку проекта и выполняем команды в терминале:

![[Pasted image 20230421192454.png]]

Что мы сделали данными командами:

1) проинициализировали репозиторий — связали нашу локальную папку something с гитом

2) через git add добавили файл README

3) сделали начальный коммит ("Initial commit")

4) с помощью команды git remote add origin подвязывает наш локальный репозиторий с удаленным репозиторием: "удаленный добавляем к настоящему (вновь созданному)", который будет находиться по адресу git@github.com название_аккаунта/название_репозитория

5) после git remote add origin обязательно пушим наши изменения: git push origin master. Т.к. мы уже подвязали к конкретному репозиторию something наш локальный репозиторий something, то вместо названия репозитория для пуша мы просто указываем origin (оно является принятым сокращением для названия репозитория), а также прописываем ту ветку, которую будем пушить _—_ master. Если мы хотим запушить текущую ветку, на которой работаем сейчас — тогда после origin пишем HEAD:

`git remote add origin HEAD`

Скорее всего появится сообщение типа "Sign in что-то там", это значит, что нам надо авторизоваться не только в браузере, но и в той системе гит, которая у нас на компьютере. Жмем на синюю кнопочку Sign in with your browser, в открывшемся окошке подтверждаем авторизацию (зеленая кнопка), затем обновляем нашу страничку на гитхабе.

Все, можно приступать к работе над проектом. Он у нас теперь и там и тут)

P.S. _—_ с этого момента и дальше будем считать, что репозиторий = проект.

#  Работа с удаленным репозиторием

## git fetch

Чтобы получить все изменения с удаленного репозитория, мы задействуем команду `git fetch`. 

`git fetch origin` — получит изменения из репозитория с именем origin.

`git fetch --all` — получит изменения из всех подключенных удаленных репозиториев.

Команда `git fetch` не обновит рабочую копию в соответствии с удаленным репозиторием. Она обновит только объекты (указатели, ветки и теги) и скачает все необходимые файлы в папу **.git/objects**.

Итак, если хотим увидеть, над чем работают остальные, то извлекаем данные с помощью команды `git fetch`. Чтобы переключиться на извлеченное содержимое, рекомендуется отдельно запустить команду `git checkout`, мы просмотрим коммиты, перед тем как интегрировать их в локальный репозиторий.

Запоминаем, что команда `git fetch` используется для синхронизации локальных объектов с этими же объектами в удаленном репозитории. Рабочую копию она не меняет.

Чтобы получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию, мы используем команду `git pull`

## git pull

`git fetch` считается "безопасным" вариантом, т.к. загружает удаленное содержимое, но не обновляет рабочее состояние локального репозитория, оставляя текущую работу нетронутой. `git pull` загружает удаленное содержимое для активной локальной ветки и сразу выполняет команду `git merge`, создавая коммит слияния для нового удаленного содержимого.

`git pull origin` — получит изменения из удаленного репозитория origin и обновит локальный репозиторий в соответствии с этими изменениями.

Имейте ввиду: `git pull  !=  git clone`. Команда `git clone` копирует весь репозиторий целиком, как есть - со всеми его файлами. Команда  `git pull` копирует разницу между удаленным и локальным репозиторием.

## git push

Команда `git push` загружает в удаленный репозиторий все наши локальные изменения. Например, мы поработали в локальном репозитории, все проверили, закоммитили и хотим закинуть на удаленный репозиторий, чтобы другие тоже видели, чем мы занимались.

`git push origin` — загрузит все изменения с текущей локального в удаленный репозиторий. Иногда выглядит так:

`git push origin main` — загрузит все изменения с текущей ветки main в удаленный репозиторий.

Порядок пуша таков: сначала имя удаленного репозитория, потом имя ветки.

`git push имя_удаленного_репозитория имя_ветки`

Закрепите данный материал, самостоятельно выполнив публикацию изменений из локальной ветки в удаленный репозиторий.

1. Выведите статус изменений в репозитории (git status);

2. Добавьте все изменения в индекс (git add);

3. Зафиксируйте проиндексированные изменения в репозитории (git commit);

4. Выполните загрузку изменений в удаленный репозиторий (git push origin).

## Когда не проходит git push

Т.е., коммит отклонен, наш пуш не прошел. Разбираемся, почему так бывает.

Git устроен так, что локально мы можем коммитить сколько угодно. Но прежде чем отправить свои коммиты на сервер, нужно подтянуть новые коммиты с сервера _—_ те самые, которые успели сделать наши коллеги. То есть сделать git pull.

Когда мы делаем git push, Git сначала проверяет _—_ нет ли на сервере новых коммитов. Если они есть, то мы видим сообщение _—_ git push rejected. Значит, нам нужно сначала сделать git pull, а затем снова запушить. Если же при попытке пуша новых коммитов на сервере нет, то git push пройдет сразу и отправит наши коммиты на сервер.

Бывает так, что когда мы сделали локальный коммит, а после этого подтянули новые коммиты с сервера, у нас в терминале появляется мердж-коммит: "Merge branch 'master' of github.com:наш_аккаунт". Мердж-коммит — это коммит, который не несет смысловой информации, кроме самого факта мерджа. В таких случаях пулльтесь с флажком ребейза _—_ `git pull --rebase origin master`. При этом наш локальный коммит окажется "поверх" нового коммита с сервера, а мердж-коммита не будет:

`git pull --rebase origin master` _—_ данная команда заберет все изменения с удаленного origin, применит к локальному origin и сольет изменения в локальную ветку master.


# Немного о том, что такое branch в Git. И немного про алиасы.

![[Pasted image 20230424220558.png]]

В выводе команды `git status` мы видим, что находимся "On master branch". Это означает, что при инициализации Git-репозитория была автоматически создана ветка (бранча) с именем master, и на данный момент мы находимся в этой ветке.

_Небольшое отступление: вообще ветка master (main) в Git — это не какая-то особенная ветка, это точно такая же, как и все остальные ветки в локальном репозитории. Она существует лишь потому, что ее создает команда `git init .`, большинство людей просто не меняет ее название. А вот origin master — это ветка на удаленном репозитории._

Создадим новую бранчу с любым именем (например, first), она будет точной копией ветки master на этом этапе. Ветка создается командой `git branch имя_ветки`.

`git branch first` — теперь у нас есть ветка first, точная копия master.

Для переключения между ветками используется команда

`git checkout имя_ветки_на_которую_переключаемся`

Например, мы можем создать ветку second с помощью `git branch second` , а потом переключиться на нее с помощью `git checkout second` . Но мы можем сделать еще круче: использовать команду, которая одновременно создаст ветку и переключит нас на нее:

`git checkout -b имя_ветки`, где "b" — расшифровывается как branch. Дадим гиту эту команду:

![[Pasted image 20230424220610.png]]

Переключаемся на ветку master, т.к. **мы должны находиться в той ветке, в которую вносим изменения из другой ветки**. А затем сделаем само слияние:

![[Pasted image 20230424220617.png]]

Теперь ветка master имеет в себе все, что есть и в ветке second, последняя нам уже не нужна, поэтому ее можно удалить командой
`git branch -d имя_ветки`:

![[Pasted image 20230424220623.png]]

Хотелось бы еще и убедиться, что у нас осталась только одна ветка master.

Если посмотрим на вывод команды с помощью `git log --pretty=format:"%h - %an, %ar : %s"` то увидим, что так и есть.

Согласитесь, команда  слишком длинная, писать ее каждый раз неудобно. Решить проблему длинных команд помогают **aлиасы**. Алиасы – это набор своих команд, которые по своей сути, короче чем базовые команды, которые мы можем добавлять сами. Другими словами, это псевдонимы команд, они эквивалентны исходным командам.

## Создадим алиас

`git config --global alias.hist "log --pretty=format:'%h - %an, %ar : %s' --graph --date=short"`

git config --global alias.hist "log --pretty=format:'%h - %an, %ar : %s' --graph --date=short"

В кавычках указываем те параметры, которые хотим видеть в логе.

Можно и локально: зайти в каталог git в файл config с помощью команды `nano config` и добавить  алиас для команды `hist`:

![[Pasted image 20230424220632.png]]

после чего выведем команду `git hist`:

![[Pasted image 20230424220640.png]]

Видим, что наш лог упорядочен в соответствии с теми настройками, что мы задали в config.

Мы создали алиас в локальном файле конфигурации. Создавать и менять псевдонимы (алиасы) можно как в глобальных файлах ( глобальный файл конфигурации расположен в `$HOME/.gitconfig`) так и в локальных файлах конфигурации (путь к локальному файлу конфигурации начинается с активного репозитория Git в `/.git/config`).

В системах Linux такой файл находится в домашнем каталоге пользователя в файле `/.gitconfig`.

Также легко можно настроить алиасы для любой команды с помощью `git config`. Подробнее можно почитать в книге про Git: [https://git-scm.com/book/ru/v2/Основы-Git-псевдонимы-в-Git](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D0%B2-Git)

Посмотреть на пример лога, созданного при помощи алиасов можно здесь [https://skazkin.su/sozdanie-komandy-git-hist-krasivyj-log-kommitov/](https://skazkin.su/sozdanie-komandy-git-hist-krasivyj-log-kommitov/)

# Что такое "форкнуть" репозиторий?

**Форк** (от англ. **fork** – вилка) – это точная копия репозитория, но только уже в нашем аккаунте на гитхабе. Fork _—_ это тоже самое, что branch в Git. Только на гитхабе такой branch называется форком.

**pull-request** (пулл реквест, запрос на pull).

**Как сделать форк?**

1. Зайти в свой аккаунт, перейти на страницу репозитория проекта и нажать кнопку _Fork_:

![[Pasted image 20230424220700.png]]

вписать название для репозитория и форкнуть (Create fork)

![[Pasted image 20230424220708.png]]

2. Склонировать репозиторий к себе на компьютер командой `git clone`. Также сразу можно создать файл README.md с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.

3. Поработать у себя, закоммитить и выполнить `git push`, чтобы загрузить наши изменения в удаленный репозиторий.GitHub подскажет, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать **pull-request**.

4. Чтобы сделать пулл-реквест, надо перейти на вкладку Pull requests

![[Pasted image 20230424220722.png]]

и выбрать New pull request

![[Pasted image 20230424220731.png]]

Откроется страница создания пулл-реквеста, где мы можем просмотреть внесенные изменения и выбрать две ветки: одну в исходном репозитории, на нее будут залиты наши изменения, вторую – в нашем репозитории, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку **Create pull request**.

Запоминаем, что с помощью форка создается точная копия оригинального репозитория, только на сервисе GitHub. В копии репозитория можно вносить свои кардинальные изменения, редактировать файлы или удалять папки. Как только все изменения будут внесены, то можно поделиться ими _—_ отправить **pull request**.
