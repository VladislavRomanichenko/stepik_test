25.04.2023    13:58
Теги: #Python #Программирование 
---
# ***Внутренние ссылки:***
[[Методы списков]]
[[Алгоритмы сортировки]]
[[Вложенные списки в Python]]
[[Матрицы Python]]
---
# ***Внешние ссылки:***

---
# ***Заметка:***

# Списки

Структура данных (data structure) — программная единица, позволяющая **хранить и обрабатывать** множество однотипных и/или логически связанных данных.

Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.

### Создание списка

Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
```

Значения, заключенные в квадратные скобки и отделенные запятыми, называются **элементами списка**.

Список может содержать значения **разных типов данных**:

```python
info = ['Timur', 1992, 61.5]
```

Обычно элементы списка содержат данные одного типа и на практике редко приходится создавать списки содержащие элементы разных типов данных.

### Пустой список

Создать пустой список можно двумя способами:

1.  Использовать пустые квадратные скобки `[]`;
2.  Использовать встроенную функцию, которая называется `list`.

Следующие две строки кода создают пустой список:

```python
mylist = []       # пустой список
mylist = list()   # пустой список
```

### Встроенная функция list

Python имеет встроенную функцию `list()`, которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки.

```python
numbers = list(range(5))
```

Точно также с помощью функции `list()` мы можем создать список из символов строки.  Для преобразования строки в список мы пишем следующий код:

```python
s = 'abcde'
chars = list(s)  # список содержит символы 'a', 'b', 'c', 'd', 'e'
```

# Основы работы со списками

### Функция len()

**Длиной списка** называется количество его элементов. Для того, чтобы посчитать длину списка мы используем встроенную функцию `len()` (от слова length – длина).

Следующий программный код:

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']

print(len(numbers))      # выводим длину списка numbers
print(len(languages))    # выводим длину списка languages
print(len(['apple', 'banana', 'cherry']))   # выводим длину списка, состоящего из 3 элементов
```

### Оператор принадлежности in

Оператор `in` позволяет проверить, содержит ли список некоторый элемент.

Рассмотрим следующий код:

```python
numbers = [2, 4, 6, 8, 10]

if 2 in numbers:
    print('Список numbers содержит число 2')
else:
    print('Список numbers не содержит число 2')
```

Мы можем использовать оператор `in` вместе с логическим оператором `not`. Например

```python
numbers = [2, 4, 6, 8, 10]

if 0 not in numbers:
    print('Список numbers не содержит нулей')
```

### Индексация

Для индексации списков в Python используются квадратные скобки `[]`, в которых указывается индекс (номер) нужного элемента в списке:

Пусть `numbers = [2, 4, 6, 8, 10]`.

![[Pasted image 20230425145211.png]]

Обратите внимание первый элемент списка `numbers[0]`, а не `numbers[1]`. 

Так же, как и в строках, для нумерации с конца разрешены отрицательные индексы.
![[Pasted image 20230425145237.png]]

### Срезы

Рассмотрим список `numbers = [2, 4, 6, 8, 10]`.

С помощью среза мы можем получить несколько элементов списка, создав диапазон индексов разделенных двоеточием `numbers[x:y]`.

Следующий программный код:

```python
print(numbers[1:3])
print(numbers[2:5])
```

```no-highlight
[4, 6]
[6, 8, 10]
```

При построении среза `numbers[x:y]` первое число – это то место, где начинается срез (**включительно**), а второе – это место, где заканчивается срез (**невключительно**). Разрезая списки, мы создаем новые списки, по сути, подсписки исходного.

Срез `numbers[:]` возвращает копию исходного списка.

Как и в строках, мы можем использовать отрицательные индексы в срезах списков.

### Использование срезов для изменения элементов в заданном диапазоне

Следующий программный код:

```python
fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']
fruits[2:5] = ['банан', 'вишня', 'киви']

print(fruits)
```

выводит:

```no-highlight
['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']
```

### Операция конкатенации + и умножения на число *

Мы можем применять операторы `+` и `*` для списков подобно тому как мы это делали со строками.

Следующий программный код:

```python
print([1, 2, 3, 4] + [5, 6, 7, 8])
print([7, 8] * 3)
print([0] * 10)
```

```no-highlight
[1, 2, 3, 4, 5, 6, 7, 8]
[7, 8, 7, 8, 7, 8]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Для генерации списков, состоящих строго из повторяющихся элементов, умножение на число — самый короткий и правильный метод.

### Встроенные функции sum(), min(), max()

Встроенная функция `sum()` принимает в качестве параметра список чисел и вычисляет сумму его элементов.

Следующий программный код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print('Сумма всех элементов списка =', sum(numbers))
```

```no-highlight
Сумма всех элементов списка = 55
```

Встроенные функции `min()` и `max()` принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.

Следующий программный код:

```python
numbers = [3, 4, 10, 3333, 12, -7, -5, 4]
print('Минимальный элемент =', min(numbers))
print('Максимальный элемент =', max(numbers))
```

```no-highlight
Минимальный элемент = -7
Максимальный элемент = 3333
```

## Отличие списков от строк

Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — **неизменяемые** объекты, а списки – **изменяемые**.


##  Вывод с помощью распаковки списка

В Python есть удобный способ вывода элементов списка без использования цикла `for`.

**Вариант 1.** Вывод элементов списка через один символ пробела:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers)
```

Такой код выведет:

```no-highlight
0 1 2 3 4 5 6 7 8 9 10
```

**Вариант 2.** Вывод элементов списка, каждого на отдельной строке

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers, sep='\n')
```

Такой код выведет:

```no-highlight
0
1
2
3
4
5
6
7
8
9
10
```

Поскольку строки содержат символы, подобно тому, как списки содержат элементы, то мы можем использовать распаковку строк точно так же, как и распаковку списков. 

Такой код:

```python
s = 'Python'

print(*s)
print()
print(*s, sep='\n')
```

выведет:

```no-highlight
P y t h o n

P
y
t
h
o
n
```

# Создание списков
![[Pasted image 20230426200629.png]]

## Списочные выражения (list comprehension)

В Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — **списочное выражение** (list comprehension).

Предыдущий код можно записать следующим образом:

```python
numbers = [i for i in range(10)]
```

Общий вид списочного выражения следующий:

`[выражение for переменная in последовательность]`

где `переменная` — имя некоторой переменной, `последовательность` — последовательность значений, которые она принимает (список, строка или объект, полученный при помощи функции `range`), `выражение` — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка.

### Примеры использования списочных выражений

**1. Создать список, заполненный 10 нулями можно и при помощи списочного выражения:**

```python
zeros = [0 for i in range(10)]
```

**2. Создать список, заполненный квадратами целых чисел от 0 до 9 можно так:**

```
squares = [i ** 2 for i in range(10)]
```

**3. Создать список, заполненный кубами целых чисел от 10 до 20 можно так:**

```python
cubes = [i ** 3 for i in range(10, 21)]
```

**4. Создать список, заполненный символами строки:**

```python
chars = [c for c in 'abcdefg']
print(chars)
```

### Считывание входных данных

При решении многих задач из предыдущих уроков мы считывали начальные данные (строки, числа) и заполняли ими список. С помощью списочных выражений процесс заполнения списка можно заметно сократить.

Например, если сначала вводится число `n` – количество строк, а затем сами строки, то создать список можно так:

```python
n = int(input())
lines = [input() for _ in range(n)]
```

Можно опустить описание переменной `n`:

```python
lines = [input() for _ in range(int(input()))]
```

Если требуется считать список чисел, то необходимо добавить преобразование типов:

```python
numbers = [int(input()) for _ in range(int(input()))]
```

Обратите внимание, мы используем символ `_` в качестве имени переменной цикла, поскольку она не используется.

Списочные выражения часто используются для инициализации списков. В Python не принято создавать пустые списки, а затем заполнять их значениями, если можно этого избежать.

### Условия в списочном выражении

В списочных выражениях можно использовать условный оператор. Например, если требуется создать список четных чисел от 0 до 20, то мы можем написать такой код:

```python
evens = [i for i in range(21) if i % 2 == 0]
```

**Важно:** для того, чтобы получить список, состоящий из четных чисел, лучше использовать функцию `range(0, 21, 2)`. Предыдущий пример приведен для демонстрации возможности использования условий в списочных выражениях.

### Вложенные циклы

В списочном выражении можно использовать вложенные циклы.

Следующий программный код:

```python
numbers = [i * j for i in range(1, 5) for j in range(2)]
print(numbers)
```

выведет список:

```python
[0, 1, 0, 2, 0, 3, 0, 4]
```

Такой код равнозначен следующему:

```python
numbers = []

for i in range(1, 5):
    for j in range(2):
        numbers.append(i * j)
print(numbers)
```

### Подводя итог

Пусть `word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six']`.

![[Pasted image 20230426200437.png]]

## Примечания

**Примечание 1.** Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.

**Примечание 2.** Обратите внимание, при выводе содержимого списка с помощью функции `print()`, все строковые элементы списка обрамляются **одинарными кавычками**. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.

# Слияние двух отсортированных списков

Слияние двух отсортированных списков в один — важная задача в информатике. Она естественно возникает при сортировке списков c использованием [сортировки слиянием](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC).

Пусть даны два отсортированных по возрастанию списка чисел `list1` и `list2`:

```python
list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
```

Простейшее решение задачи слияния списков использует списочный метод `sort()`:

```python
def merge(list1, list2):
    result = list1 + list2   # создаем результирующий список
    result.sort()            # сортируем список встроенным методом sort()
    return result            # возвращаем отсортированный список

list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
list3 = merge(list1, list2)  # вызываем функцию слияния двух отсортированных списков
print(list3)
```

Результатом работы такого кода будет список:

```no-highlight
[0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]
```

И хотя функция `merge()` полностью справляется с своей задачей, она абсолютно не учитывает то, что два списка `list1` и `list2` уже отсортированы.

## Быстрое слияние двух отсортированных списков в один

Пусть мы имеем два уже **отсортированных по возрастанию** списка `list1` и `list2`.

Алгоритм быстрого слияния следующий:

1.  Создаем численные указатели `p1 = 0` и `p2 = 0` на начала обоих списков `list1` и `list2` соответственно;
2.  На каждом шаге берем меньший из двух элементов `list1[p1]` и `list2[p2]`;
3.  Записываем его в результирующий список; 
4.  Увеличиваем указатель на первый элемент списка (`p1` или `p2`) из которого был взят элемент на 1;
5.  Когда один из начальных списков закончился, добавляем все оставшиеся элементы второго списка в результирующий список.

```python
def quick_merge(list1, list2):
    result = []

    p1 = 0  # указатель на первый элемент списка list1
    p2 = 0  # указатель на первый элемент списка list2

    while p1 < len(list1) and p2 < len(list2):  # пока не закончился хотя бы один список
        if list1[p1] <= list2[p2]:
            result.append(list1[p1])
            p1 += 1
        else:
            result.append(list2[p2])
            p2 += 1

    if p1 < len(list1):   # прицепление остатка
        result += list1[p1:]
    if p2 < len(list2):
        result += list2[p2:]
    
    return result
```

Следующий программный код:

```python
list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
list3 = quick_merge(list1, list2)
print(list3)
```

выведет:

```no-highlight
[0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]
```