21.04.2023    16:31
Теги: #Git 
---
# ***Внутренние ссылки:***

---
# ***Внешние ссылки:***
[ 2.4 Основы Git - Операции отмены](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D1%8B)
---
# ***Заметка:***

# Команды:

`git log` — показывает историю коммитов

`git checkout -- file1.txt` — отменяет изменения в рабочем каталоге, переключает на указанный файл

`git checkout хэш-коммита` — переводит на любой коммит в истории наших изменений

`git diff --staged` — выводит разницу между индексом и последним коммитом

`git show`  — показывает информацию по отдельному коммиту

`git reset` — позволяет удалять коммиты

`git reset``--hard HEAD~2` — используется для удаления двух последних коммитов

`git revert` — используется для обращения изменений, внесенных в коммит из истории проекта.

`git clean`  — используется для операций с неотслеживаемыми файлами.

# Прыгаем по коммитам

Зайдем в file1.txt (все та же папка myproject) и добавим какой-то текст. Выходим, смотрим статус (он modified), видим, что изменение было проиндексировано и готово к коммиту.

![[Pasted image 20230421163430.png]]

Тут мы понимаем, что зря в этот файл что-то добавляли и хотим это действие (добавление) отменить. Но файл уже в индексе.

'используй "git restore "  для отмены изменений в рабочем каталоге' — похоже на то, что нам нужно, только эта команда `_git restore имя_файла_` восстановит файлы рабочего каталога до изменений, нам это не нужно.

Есть еще команда `_git restore --staged имя_файла_` — она удалит конкретный файл из индекса. Нам же нужно просто отменить изменение, сделанное нами в файле, который уже в статусе modified.

Обратите внимание на пробелы до и после `--` :

![](https://ucarecdn.com/eccb4c75-431f-4adc-a809-44ead9a0b79c/)

Данная команда `git checkout -- имя_файла` отменяет локальные изменения, сделанные до их индексации. Если теперь мы выполним индексирование (`git add`) и коммит (`git commit`) для файла file1.txt (на который переключились), то тем самым восстановим старую версию файла. Удалятся все изменения в файле до команды `git checkout -- file1.txt`

И не забудем статус проверить — надо же убедиться, что все сделали правильно!

![](https://ucarecdn.com/0c9a40f9-3103-46e3-90a9-c6571cf5da7e/)

Запоминаем, что `git checkout -- имя_файла` — для отмены изменений в файлах, которые в статусе modified, еще не закоммичены. С  помощью этой команды файл будет возвращен в первичное состояние коммита.

![[Pasted image 20230421163355.png]]


## `git checkout` 

Вообще в Git под термином **checkout** подразумевают **переключение** между различными объекта. Команда `git checkout` работает с тремя различными объектами:

- файлами,

- коммитами

- ветками.

Выше мы рассмотрели `git checkout` по отношению _**к файлам**_.

Для того, чтобы перейти _**на другой коммит,**_ чтобы, например, посмотреть на его содержимое, нам нужна команда `git checkout` и 40-символьный хэш коммита. После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

В приведенном ниже примере мы с помощью `git checkout 822f2c1ed916557cf278e510b5b042297f31ce14` переключились на указанный коммит —  указатель HEAD стоит на коммите 822f2c1ed916557cf278e510b5b042297f31ce14

![](https://ucarecdn.com/aaa63242-86f1-46d2-b9b3-f087fd916b76/)

Можно указывать не весь хэш, а несколько начальных символов хэша.

Каждый коммит содержит состояние проекта в определенный момент времени и указатель на предыдущий коммит. Мы уже знаем, что Git ссылается на коммит по его хэшу. А вот чтобы отслеживать историю, Git в каждом коммите хранит указатель `HEAD`.

При стандартном процессе разработки указатель **`HEAD`** обычно указывает на главную ветку `main` или другую локальную ветку. Или еще можно объяснить **HEAD** как указатель на текущую ветку, которая, в свою очередь, является указателем на последний коммит, сделанный в этой ветке. Но при переключении на предыдущий коммит **`HEAD`** указывает уже не на ветку, а непосредственно на сам коммит.

В нашем случае (переключились на другой коммит с помощью чекаута) **HEAD — это указатель** на коммит (он будет теперь первым, т.к. мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам).

Гит пояснил, что после того, как мы сделали чекаут на коммит `822f2c1` указатель HEAD переместился на данный коммит:

![](https://ucarecdn.com/e22e2348-0f24-40a9-b19b-ec04a01f2447/)

Чтобы вернуться обратно после просмотра коммита, мы снова используем `git checkout` с символом тире:

`git checkout -`

После этой команды мы вернем состояние репозитория в ту точку, где были до перехода. Даже если переход был на коммит в другой ветке, возврат будет происходить с перепрыгиванием на ту ветку, где мы изначально находились.

С помощью `git checkout` мы можем перемещаться **между ветками**. При переключении ветки происходит обновление файлов в рабочем каталоге в соответствии с версией, хранящейся в этой ветке, Git начинает записывать все новые коммиты уже в этой ветке.

Сейчас у нас одна ветка master (main), но перепрыгнули мы на ту ее версию, которая была для коммита `822f2c1` То есть мы находились на самой последней версии ветки master, потом прыгнули на ту версию ветки master (main), которая была именно в тот момент времени, когда мы делали коммит `822f2c1ed916557cf278e510b5b042297f31ce14`.

Проверить, что мы находимся в той версии проекта, которая была для коммита `822f2c1`, можно с помощью `git log`.

Для возврата на прежнюю версию ветки master (main), в которой мы работали до прыжка, нам снова нужна команда `git checkout имя_ветки` — в нашем случае это master (ветка-то у нас одна), но попадем мы уже именно в ее последнюю версию (Switched to branch 'master'):

![](https://ucarecdn.com/47fde991-f293-408a-a8ce-be4d1959013c/)

`git checkout master`  "перекидывает" указатель HEAD на самый верх — в последнюю версию наших изменений. Вот так можно возвращаться на предыдущие версии, не стирая самую последнюю версию.

Задав команду `git log`, мы видим, что HEAD -> master:

![](https://ucarecdn.com/80953d99-21db-4c89-a92f-6830822456d3/)

## Как посмотреть, что будет записано в git log перед тем, как сделать коммит?

Создадим файл newfile.txt с каким-нибудь безумным текстом, добавим его в индекс. Даем гиту команду `git diff --staged`,  чтобы посмотреть, что добавится в лог:

![](https://ucarecdn.com/4f2972eb-8eb4-4f01-abdf-569034ed9939/)

Не обращаем внимание на служебные данные. Вывод `git diff` содержит именно те строки, которые изменились, а не файлы целиком. Видим "_+++_" и наш добавленный файл и ниже его содержание. Если нам все нравится — делаем коммит, если нет — можем вернуться в файл и справить то, что накосячили не так сделали.

По умолчанию `git diff` показывает изменения только для тех отредактированных файлов, которые еще не были добавлены в коммит. А вообще в Git эта команда используется для вычисления разницы между любыми двумя сущностями: 

- между нашей рабочей копией и индексом (собственно `git diff` )

- между индексом и последним коммитом ( `git diff --staged` )

- между любыми двумя коммитами (`команду узнаем позже`)

# Что такое HEAD.

Git управляет содержимым трех разных наборов файлов (эти наборы правильнее называются **деревьями**): HEAD, Индекс и Рабочий каталог:

1. Набор файлов (= дерево) "HEAD" содержит снимок самого последнего коммита. 

2. Набор файлов (=дерево) "Индекс" содержит снимок следующего намеченного коммита.

3. Набор файлов (=дерево) "Рабочий Каталог" — своеобразная песочница файлов и папок.

## HEAD 
— это указатель на текущую ветку, которая, в свою очередь, является указателем на последний коммит, сделанный в этой ветке. Или другими словами снимок нашего последнего коммита — это и есть HEAD. Это значит, что HEAD будет родителем следующего созданного коммита в данной ветке. Каждый последующий коммит хранит ссылку на своего родителя (предыдущий коммит). По мере добавления новых коммитов, первый коммит (корневой) будет смещаться вниз списка, а указатель HEAD всегда будет ссылаться на ветку, которая в свою очередь ссылается на последний коммит.

При стандартном процессе разработки указатель HEAD указывает на текущую ветку, но когда мы переключились на предыдущий коммит (сделали `git checkout хэш_коммита`), то HEAD теперь указывает уже не на ветку, а непосредственно на сам коммит. **Коммиты в Git**, хоть и представляют собой цепочки, **ветками не считаются**.

Технически HEAD — это файлик, в котором Git прописывает хэш коммита, на который ссылается этот указатель. Каждая ветка представляет собой ссылку на текущий коммит. А HEAD — это ссылка, которая указывает на текущую ветку. При переключении между ветками проекта происходит переключение HEAD на указанную ветку.

## Индекс
— это наш следующий намеченный коммит. Мы уже разбирали это понятие как "промежуточная область, область подготовленных изменений" Git — то, что Git просматривает, когда мы выполняем `git commit`. Git заполняет индекс списком изначального содержимого всех файлов, добавленных в последний раз в наш рабочий каталог. Когда мы заменяем некоторые из таких файлов их новыми версиями, то команда `git commit` преобразует изменения в дерево для нового коммита.

## HEAD и Индекс 
сохраняют свое содержимое эффективным, но неудобным способом внутри каталога `.git`. Рабочий Каталог распаковывает содержимое HEAD и Индекса в настоящие файлы, что упрощает нам их редактирование. В Рабочем Каталоге мы можем опробовать изменения перед их коммитом в индекс, а затем в историю.

Когда мы вначале делаем команду `git init .`, которая создаст Git-репозиторий, у данного репозитория ссылка HEAD будет указывать на еще несуществующую ветку (master branch, origin). Когда мы создали какой-то файл, на данном этапе только дерево Рабочего Каталога будет его содержать:

![[Pasted image 20230421165253.png]]

Теперь мы хотим закоммитить этот файл, поэтому мы используем `git add` для копирования содержимого Рабочего Каталога в Индекс:

![[Pasted image 20230421165259.png]]

Затем, мы выполняем команду `git commit`, которая сохраняет содержимое Индекса как неизменяемый снимок. Если сейчас выполнить `git status`, то мы не увидим никаких изменений, так как все три дерева одинаковые:

![[Pasted image 20230421165307.png]]

Таким образом, всегда есть три активные копии каждого файла:

-   один в HEAD;
-   один в Индекс;
-   один в Рабочем Каталоге.

Команда `git status` просматривает все три, сначала сравнивая HEAD и Индекс  (Git выявляет список изменений, которые необходимо зафиксировать), а затем Индекс и Рабочий Каталог (Git определяет список изменений, не подготовленных для фиксации).

Команда `git add` копирует из Рабочего Каталога в Индекс.

Команда `git commit` создает объект коммита, который указывает на этот снимок.

А еще команда `git commit` обновляет `master branch` так, чтобы она тоже указывала на этот коммит:

![[Pasted image 20230421165314.png]]

Теперь мы изменим файл file.txt и закоммитим его, в таком случае у нас будет версия файла **v2** и на следующих рисунках показано, как она постепенно становится красным цветом.

Сначала мы отредактируем файл в нашем рабочем каталоге:

![[Pasted image 20230421165320.png]]

Посмотрим его статус: будет красный modified, т.к. его представления в Индексе и Рабочем Каталоге различны. Затем выполним `git add` для этого файла, чтобы поместить его в Индекс:

![[Pasted image 20230421165327.png]]

Посмотрим теперь его статус: зеленый modified. Он выделен зеленым цветом — значит это изменения, которые будут закоммичены, ведь Индекс и HEAD различны.  Наш следующий намеченный коммит сейчас отличается от нашего последнего коммита. Наконец, мы выполним `git commit`, чтобы окончательно совершить коммит:

![[Pasted image 20230421165338.png]]

Все три дерева снова одинаковые, а `git status` покажет: On master branch, No commits yet, nothing to commit.

Переключение веток и клонирование проходят через похожий процесс. Когда мы переключаемся на ветку, HEAD начинает также указывать на новую ветку, Индекс замещается снимком коммита этой ветки, и затем содержимое Индекса копируется в Рабочий Каталог.

# Отмена сделанных изменений в коммите

## 1. Изменения в последнем коммите

Допустим, у нас есть проект, в котором мы уже сделали 4 коммита (сверху вниз, новые снизу):

![[Pasted image 20230421170628.png]]

В последнем коммите `9773е52` мы забыли добавить в один из файлов (например, в index.html) пару строк. Вносим пару строк в index.html, добавляем наши изменения в индекс и...

Можно конечно сделать новый (пятый) коммит, но так мы засоряем историю, ведь уже есть хороший 4-й коммит. Неплохо было бы объединить оба коммита в один. 

Для этого нам нужно команду `git commit` применить с параметром `--amend`

Команда `git commit --amend` запустит одновременно редактор с предложением изменить сообщение предыдущего коммита. Мы можем его изменить, если нужно. Для выхода с сохранением изменений используем команду

`:wq`

Если мы не собираемся менять сообщение, то пропускаем этот этап добавлением параметра `--no-edit`:

`git commit --amend --no-edit`

Текстовый редактор для изменения сообщения открываться не будет, мы сразу получим единый коммит — пятый коммит заменит результаты четвертого, сам же и став четвертым.

Данная команда отлично выручает, если мы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит:

`git commit -m 'first commit'`

`git add some_file`

`git commit --amend --no edit`

Если к команде `git commit --amend` добавить ключ -m, то мы можем передать новый комментарий из командной строки, не открывая текстовый редактор. Сама команда перезапишет сообщение последнего коммита и полностью заменит последний коммит. Измененный коммит станет новой сущностью с отдельной ссылкой, поэтому такое перезаписывание истории лучше делать только до того, как отправили коммит на сервер:

![[Pasted image 20230421170637.png]]

Надо быть осторожными при использовании флага `--amend` с коммитами, доступными другим членам команды. Изменение коммита, доступного другому пользователю, может привести к путанице и длительным устранениям конфликтов при слиянии.

Чтобы продолжить разработку, необходимо вернуться к текущему состоянию проекта:

`git checkout master`


## 2. Изменение не последнего коммита (или нескольких коммитов)

Во втором коммите `a1e8fb5` мы тоже хотели что-то изменить, переключаемся на него с помощью `git checkout a1e8fb5`

Изменим файлы, добавим все в индекс и закоммитим. В логе у нас теперь пять коммитов:  `a1e8fb5` является вторым, а  только что созданный на его основе новый коммит - пятым (например, `ft371s9`). Можно оставить этот пятый коммит, но так мы опять засоряем историю. А можно с помощью команды `git rebase`  объединить новый (самый свежий, последний в логе) коммит и не последний коммита (в данном случае второй) в новый базовый коммит с тем же хэшем `a1e8fb5`.

В этом случае новый коммит заменит старый (но хэш останется от старого). Кстати, поэтому команду `git rebase` запрещено применять к коммитам, которые стали доступны публично — история проекта просто исчезнет.

Для начала выполняем команду `git rebase` с флагом  `-i`.  Флаг дает возможность изменять отдельные коммиты в процессе, а не перемещать все коммиты, как в стандартном режиме команды `git rebase`. Без флага `git rebase` позволяет перезаписать историю: она автоматически применяет коммиты в текущей рабочей ветке к указателю HEAD переданной ветки.

После того, как мы введем команду `git rebase -i` откроется редактор, в котором мы можем указать что хотите сделать:

r (reword) — переименовать коммит

e (edit) — изменить коммит

s (squash) — склеить два или больше коммитов
![[Pasted image 20230421170645.png]]
Рядом с коммитом вместо `pick` впишем `e` для редактирования коммита или `r` для переименования. Сохранив файл, мы увидим подсказку от Git:
![[Pasted image 20230421170653.png]]
Все изменения добавляем с помощью git add и коммитим с параметром `--amend`

`git commit --amend`

После успешного коммита, следуя подсказке гита (на скриншоте), выполняем `git rebase --continue`

# Отмена самих коммитов

(удаление коммитов предшествующих какому-то определенному коммиту)

Git по большей части система "только вперед" — лучше создать что-то новое, а не изменить/удалять старое. В Git все проблемы с изменениями обычно решаются новым коммитом, изменяющим код в нужном направлении. Это удобно и безопасно, т.к. изменение истории коммитов может вызвать проблемы при синхронизации с удаленным репозиторием.

Все же внутри Git существуют специальные команды, позволяющие отменить **любой** коммит. Среди них:

- переключение (checkout, рассмотрели раньше),

- сброс (reset),

- возврат (revert),

- очистка (clean) и другие.

## Рассмотрим отмену коммита с помощью этих команд.

### 1. Откат в предыдущее состояние с помощью `git reset`.

Команда `git reset` считается методом локальной отмены, который безопасно изолирует удаление коммитов от других веток. Идеально подходит, когда надо удалить только что сделанный по ошибке коммит, который еще не отправлен в удаленный репозиторий. Команда `git reset` позволяет удалять коммиты, но ее можно делать только в том случае, если речь идет про новые коммиты, которых нет ни у кого, кроме нас. А вот если коммит был отправлен во внешний репозиторий, например, на GitHub, то менять историю ни в коем случае нельзя, это сломает работу у тех, кто работает с нами над проектом.

Команда `git reset` применяется **_чаще всего_** в двух случаях:

1) Команда `git reset хэш_коммита` —  отменяет все коммиты после заданного, оставляя все изменения в рабочем каталоге.

2) Команда `git reset --hard хэш_коммита` —  сбрасывает всю историю вместе с состоянием рабочего каталога до указанного коммита.

 Для начала выведем историю коммитов с помощью `git log`:

![[Pasted image 20230421174138.png]]

Видим наши два коммита: первый (first commit) и второй (second commit)

Теперь произведем откат к первому коммиту с помощью `git reset хэш_коммита`. Мы сбросим историю до указанного коммита, но оставим внесенные изменения в файлах:

![[Pasted image 20230421174143.png]]

Теперь произведем откат к первому коммиту с помощью `git reset --hard хэш_коммита`. Мы сбросим историю до указанного коммита и вернем файлы к исходному состоянию:

![[Pasted image 20230421174148.png]]

Команда `git reset хэш_коммита` перемещает указатель на выбранный коммит, а флаг `--hard` еще и обновляет все файлы в соответствии с этим коммитом. Команда `git reset --hard хэш_коммита` довольно опасна, т.к. любая работа, находившаяся в состоянии ожидания в разделе проиндексированных файлов и рабочем каталоге, будет потеряна.

Вообще у команды `git reset` есть три режима:

1. git reset --soft (перемещение указателя HEAD)

2. git reset --mixed (обновление Индекса), то же самое, что `git reset`

3. git reset --hard (обновление Рабочего каталога)

Команда `git reset --soft` выполняет обновление указателя HEAD, и на этом операция сброса останавливается. Например, у нас есть ветка с коммитами A, B и C, C — это последний сделанный нами коммит:

![[Pasted image 20230421174154.png]]

Указатель HEAD говорит о том, что мы сейчас на главной ветке main на коммите С. После выполнения команды `git reset --soft B` указатель HEAD передвинется на **B**:

![[Pasted image 20230421174200.png]]

main теперь тоже указывает на **B**, изменения из коммита **C** будут в индексе, как будто мы их добавили командой `git add`, но последняя команда `git commit` для **C** будет отменена. Команда `git reset --soft B` просто передвинет указатель HEAD, и на этом операция сброса останавливается. Обновлять Индекс содержимым коммита **B** Git не будет.

Команда `git reset --mixed` равносильна команде `git reset`. Она выполняет 2 вещи:

- отменяет последний коммит **C**

_-_ отменяет добавление в индекс всех файлов.

![[Pasted image 20230421174210.png]]

HEAD также переместится на **B**, но на этот раз изменения из коммита **С** не попадут в Индекс. Индекс станет таким же, как и HEAD. Мы откатимся назад до момента выполнения команд `git add` и `git commit`, команда `git status` покажет, что все изменения not staged. Чтобы их закоммитить нужно сначала добавить их в индекс командой `git add` и только после этого `git commit`.

Команда `git reset --hard` приведет Рабочий Каталог к тому же виду, что и Индекс. Т.е. мы отменим последний коммит **С** и все незакоммиченные изменения, а файлы в репозитории будут совпадать с **B**. Этот режим подразумевает потерю изменений, поэтому перед его выполнением мы обязаны проверять `git status`, чтобы убедиться что нет незакоммиченных изменений(или они не нужны).

Например, мы создали файл newfile.txt, закоммитили его для дальнейшей отправки с помощью команды `git push` в удаленный репозиторий:

![[Pasted image 20230421174220.png]]

Тут мы поняли, что не хотим его пушить. Хотим удалить вообще этот коммит:

![[Pasted image 20230421174223.png]]

Указатель HEAD перешел на коммит 47a299d..... Флаг `--hard` означает полное удаление. Если не указывать флаг `--hard`, то по умолчанию подразумевается флаг `--mixed`, т.е. коммит отменится, но не удалится, все изменения этого коммита переместятся в рабочий каталог, так что с ними можно будет продолжить работать (исправить или отменить и выполнить новый коммит). `HEAD~` означает "один коммит от последнего коммита". Если бы мы хотели удалить два последних коммита, то могли бы написать `HEAD~2`.

![[Pasted image 20230421174228.png]]
!!!! НЕ СООТВЕТСТВУЕТ ДЕЙСТВИТЕЛЬНОСТИ, ИНФУ ИЗ ДОКУМЕНТАЦИИ СМОТРЕТЬ В КОНЦЕ !!!!
``Допустим, мы сделали 4 версии (4 коммита): A, B, C и D, и хотим удалить 2 последние версии. В таком случае используем команду `git reset``--hard HEAD~2`.  А вот если мы хотим стереть все версии до последней D, то нам нужна команда `git reset``--hard HEAD~3`.  До коммита D удалятся 3 коммита: A, B, и С и по сути у нас обнулится лог: коммит D будет самой первой версией нашего проекта. Остальные коммиты просто исчезнут: мы стерли историю коммитов)``

### 2. Команда `git clean`
— это инструмент для управления рабочим каталогом, используется для отмены изменений, не подтвержденных коммитами (используется для операций с неотслеживаемыми файлами). Отменить действие команды `git clean` нельзя, она обеспечивает окончательное удаление данных из файловой системы, поэтому перед выполнением убедитесь, что неотслеживаемые файлы действительно нужно удалить.

### 3. Команда `git revert`
безопаснее, чем reset, так как она отменяет общую историю коммитов, но не удаляет коммиты из нее. Это типичная команда отмены изменений, но вместо удаления коммита из истории проекта она отменяет внесенные в нем изменения и добавляет новый коммит с полученным содержимым. В результате история в Git не теряется, что важно для обеспечения целостной истории версий и надежной совместной работы.

`git revert` используем, когда нужно обратить изменения, внесенные в некоем коммите из истории проекта. например, у нас баг появился в проекте из-за конкретного коммита, и чтобы не переходить к этому коммиту вручную, исправлять его и выполнять коммит нового снимка состояния, мы используем `git revert` + ссылка на коммит (тот самый 40-символьный хэш):

![[Pasted image 20230421174236.png]]

Она (команда) откатывает изменения в истории коммитов репозитория. Если `git checkout` и `git reset` перемещают указатель `HEAD` и указатели ветки на определенный коммит, то  `git revert` не трогает указатели вообще. Мы просто переходим к указанному коммиту, его изменения обращаются и создается новый, «обратный» коммит. Затем позиция указателей обновляется — они перемещаются к этому коммиту в конце ветки.

Причем, эта команда отменяет не только последний коммит, но и любой другой коммит из истории проекта, что очень круто. Без системы контроля версий о таком нельзя было и мечтать!

Таким образом, операции отмены в Git позволяют нам перемещаемся назад во времени или на другую временную шкалу, где ошибок не было:

![[Pasted image 20230421174245.png]]



# КРАТКО И ПРАВИЛЬНО


> А вот если мы хотим стереть все версии до последней D, то нам нужна команда `git reset``--soft HEAD~3`.  До коммита D удалятся 3 коммита: A, B, и С и по сути у нас обнулится лог: коммит D будет самой первой версией нашего проекта. 

**Из документации:**

Команда reset в заранее определённом порядке перезаписывает три дерева Git, останавливаясь тогда, когда вы ей скажете:

1.  _`--soft`_ Перемещает ветку, на которую указывает HEAD (на этом останавливается)
    
2.  `--mixed` Делает тоже что `--soft` но еще и индекс делает таким же как HEAD (на этом останавливается)
    
3.  _`--hard`_ Делает тоже что  `--mixed` и дополнительно делает Рабочий Каталог таким же как HEAD и Индекс.
    

Было 3 коммита и наше текущее состояние такое: 

![[Pasted image 20230421175903.png]]

_`--soft`_ Перемещает ветку, на которую указывает HEAD:

![[Pasted image 20230421175957.png]]

`--mixed` дополнительно и индекс делает таким же как и HEAD (на этом останавливается):

![[Pasted image 20230421175945.png]]

_`--hard`_ Делает еще и Рабочий Каталог таким же как HEAD и Индекс.
![[Pasted image 20230421180012.png]]