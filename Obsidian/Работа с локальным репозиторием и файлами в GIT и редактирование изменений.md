20.04.2023    13:22
Теги: #Программирование #Git 
---
# ***Внутренние ссылки:***
[[Редактирование изменений GIT]]
[[ Прыгаем по коммитам (git checkout),  указатель HEAD, изменения в коммите и их отмена]]
[[Статусы (состояния) файла в GIT]]
[[Работа с .gitignore]]
---
# ***Внешние ссылки:***

---
# ***Заметка:***

# !Команды!

`git init .` – создает новый репозиторий

`git status` – отображает список измененных, добавленных и удаленных файлов

`git add`  – добавляет указанные файлы в индекс

`git add --all` - добавляет все файлы в индекс

`git reset` – отменяет действие команды git add на файл

`git commit -m` – фиксирует добавленные в индекс изменения с определенным сообщением

`git push` – отправляет изменения на удаленный репозиторий

## Редактирование изменений

`git log` — показывает историю коммитов

`git log -2` — показывает последние 2 коммита

`git log -p` — расширенный вывод истории: выводит то же, что и git log, но еще и с изменениями в файлах

`git log --oneline`  — выводит коммиты в одну строку, показывая только хэш коммита и commit message

`git log --pretty=format:" "` — меняет формат вывода лога в соответствии с указанными в кавычках параметрами

`git show`  — показывает информацию по отдельному коммиту

## Прыгаем по коммитам

`git checkout -- file1.txt` — отменяет изменения в рабочем каталоге, переключает на указанный файл

`git checkout хэш-коммита` — переводит на любой коммит в истории наших изменений

`git diff --staged` — выводит разницу между индексом и последним коммитом

## Отмена коммитов

`git reset` — позволяет удалять коммиты

`git reset``--hard HEAD~2` — используется для удаления двух последних коммитов

`git revert` — используется для обращения изменений, внесенных в коммит из истории проекта.

`git clean`  — используется для операций с неотслеживаемыми файлами.

# !Краткое содержание всех коспектов, связанных с этим!

1. Чтобы сделать файл отслеживаемым, используем команду `git add`

2. Когда мы делаем файл отслеживаемым, происходит следующее:

   2.1. Создается блоб-объект для этого файла с именем – 40-символьным хэшем содержимого файла, причем его первые две буквы называют подпапку в папке .git/objects, а остальные 38 – сам файл. Такое разделение имени ускоряет поиск blob-файла среди других.

   2.2. Имя этого blob-файла записывается в индекс и с этого момента GIt считает файл подготовленным к коммиту.

3. Если мы поменяем содержимое файла, нам нужно снова добавить его в индекс.

4. Индекс — промежуточное место между нашим прошлым коммитом и следующим. Мы можем добавлять или удалять файлы из индекса, а также просмотреть индекс с помощью `git status`.

5. Команда `git status` показывает, на каком этапе мы сейчас находимся

5. Коммиты создаются с помощью команды `git commit`, которая делает снимок состояния проекта на текущий момент времени. Коммиты снимков состояния Git всегда выполняются в локальный репозиторий.

# !Краткое содержание этого конспекта!

На базе папки my-project с помощью команды `git init .` мы инициализировали репозиторий Git. Теперь наш проект (наша папка) my-project будет отслеживаться гитом. Директория `.git` – это база данных Git. Именно в нее будут сохранятся все наши изменения.

В папке my-project мы создали файл, который гит увидел, но сначала не отслеживал его изменения. Чтобы он его отслеживал, мы добавили файл в индекс командой `git add` и закоммитили командой `git commit -m "описание"`. Во время коммита мы берем все подготовленные изменения (они могут включать любое количество файлов) и отправляем их в репозиторий как единое целое.

# **Как создать локальный Git-репозиторий?**

Существует два способа: _создать (инициализировать) новый_ или _клонировать уже существующий_.

## В первом случае 

(при инициализации) мы связываем наш проект с системой Git, придерживаясь следующего алгоритма действий:

1) на своем компьютере создаем папку будущего проекта, переходим в нее и инициализируем репозиторий в ней с помощью команды `git init .`     Точка после пробела в конце команды обязательна.

2) репозиторий готов к работе: можем добавлять в него свои файлы, редактировать их, удалять и т.д.

3) после этого делаем коммит изменений, который говорит, что теперь новые файлы готовы к отправке в удаленный репозиторий

4) связываем локальный и удаленный репозитории с помощью определенной команды, которая дает Git'у знать, где находится удаленный сервер (куда отправлять файлы)

5) отправляем данные в удаленный репозиторий используем команду `git push.`

Если мы хотим использовать Git для уже имеющегося у нас проекта, делаем все то же самое, открыв нужный каталог.

## Во втором случае 

мы хотим скопировать репозиторий из удаленного хранилища (например, GitHub). Мы будем клонировать себе его копию, выполним команду git clone с указанием ссылки на удаленный репозиторий.

## Начало создания

Для начала создадим в терминале папку "my-project" и зайдем в нее с помощью команды `cd my-project`

Для того, чтобы подключить гит, нужно создать базу данных для него с помощью команды  `git init .` Это создаст на базе текущей папки my-project новый подкаталог .git (репозиторий Git), в котором и будет содержаться вся конфигурация Git и история проекта. 

!!! Точка после команды говорит о том, что именно в этой папке, где мы сейчас находимся (my-project), и будет база данных git.

Папка my-project теперь является локальным репозиторием. Она будет отслеживается гитом. Все файлы истории хранятся в специальной папке .git/ которую гит сам создаст внутри папки my-project:

![[Pasted image 20230420141958.png]]

Если вдруг после `git init .` не появляется папка .git в папке my-project, проверьте ее на "скрытность", возможно, папка .git была скрыта настройками вашей операционной системы.

Посмотрим, что у нас создалось с помощью команды `ls -la` 

## Что Git хранит в локальном репозитории? Функции файлов

Итак, с помощью `git init .` мы создали на базе текущей папки my-project локальный репозиторий, в котором содержится вся конфигурация Git и история проекта.

Зайдем в эту директорию с помощью команды `ls .git` и рассмотрим, какие файлы и папки она содержит.

![[Pasted image 20230420142318.png]]

1) В папке **hooks** гит хранит набор скриптов, которые могут автоматически запускаться во время выполнения git команд.

2) В папку **info** гит заботливо поместит файл exclude, в котором можно указывать любые файлы, и гит не станет добавлять их в свою историю. Это почти то же самое что и .gitingnore (рассмотрим чуть позже), за тем исключением, что exclude не сохраняется в истории проекта, и мы не сможем им поделиться с другими.

3) В папке **logs **гит будет хранить историю проекта для всех веток в этом проекте.

4) В папке **objects** гит соберет blob-объекты, каждый из которых проиндексирован уникальным SHA. Не заморачиваемся, просто доверяем гиту))

5) В папку ** refs** гит закинет копию ссылок на объекты коммитов в локальных и удаленных ветках.

6) **FETCH_HEAD**  и **MERGE_HEAD ** хранят в себе ссылки в виде SHA на ветки, которые участвовали соответственно в `git fetch` или `git merge`. 

7) В файле *COMMIT_EDITMSG* содержится последнее введенное нами сообщение коммита ( к коммиту надо добавлять сообщение)

8) Файл **config** содержит настройки Git репозитория

9) Файл **description** содержит в себе название проекта и его описание. Он предназначен для GitWeb, специального веб-интерфейса, написанного для просмотра Git репозитория через веб-браузер.

10) Файл **HEAD** содержит ссылку на текущую ветку, в которой мы работаем.

11) Файл **index** является промежуточной областью с файлами, которые уже упакованы Git. Это хранилище для файлов с изменениями, информация о которых потом попадет в единый коммит.

12) В файл **ORIG_HEAD** будут попадать ветка, с которой проводилось слияние.


## Как посмотреть информацию о статусе файлов, находящихся в репозитории?

`git status` – данная команда выводит информацию о статусе файлов, находящихся в репозитории. Она нам покажет, **что** сейчас происходит, на каком этапе мы сейчас находимся, каков статус всех файлов: количество untracked (неотслеживаемых), deleted (удаленных), new (новых) и прочих файлов, количество коммитов, на которое отличается локальная версия репозитория от удаленного и т.д.

`echo "Source file1" > file1.txt`

Команда "echo "содержимое файла" > название_файла" создает файл с указанным содержимым.

Теперь зададим команду `git status` и посмотрим, как поведет себя гит:

![](https://ucarecdn.com/6ab6e58a-7d57-4fe3-85ac-d0e1e4f621f1/)

Гит увидел новый для него файл, подсветил его красным цветом и определил, что он – Untracked. В данном состоянии Git просто знает об этом файле в проекте,  но еще не отслеживает его изменения. 

Чтобы отслеживать файл, мы должны его зафиксировать (сделать коммит). Но прежде чем зафиксировать, нам надо подготовить его к фиксации — отправить его в промежуточную область — Stage (Staging area, Индекс, стадия подготовленных файлов).

## Что такое Stage/Staging area?

Stage ("стейдж") — стадия/область подготовленных файлов. Технически это просто файлик, содержащий имена файлов и изменения в них, которые должны войти в следующий коммит.

Для добавления файла в Stage используется команда `git add`, а сам процесс добавления файлов в промежуточную область называется индексацией. Индекс — промежуточное место между нашим прошлым коммитом и следующим. 
Мы можем добавлять или удалять файлы из индекса, а можем просто просмотреть индекс с помощью команды `git status`.

***Команда `git add` добавляет файлы в индекс.***

***Команда `git reset` удаляет файлы из индекса.***

## Для чего разработчику индексация

Вообще понятие индекса в Git появилось неслучайно. Ведь когда разработчик работает пусть даже над одной задачей, то выполняя ее, он вместе с тем исправляет и разные недочеты в коде. В итоге в рабочей директории появляется много разных исправлений, которые частично относятся к выполняемой задаче, а частично содержат исправления, напрямую не связанные с основными изменениями. И если делать ровно один коммит, включающий в себя и основную задачу, и дополнительные исправления, то будем иметь неприятные побочные эффекты:

- сложнее смотреть историю, ведь коммит начинает содержать совершенно несвязанные изменения, которые отвлекают во время ревью;

- откат коммита по любым причинам приведет к тому, что откатятся правки, которые все равно нужно будет делать.

Именно здесь помогает индекс: он позволяет меньше переживать на тему того, как сформируется коммит.

С помощью индексации гиту не приходится отслеживать все файлы в проекте, т.к. некоторые файлы (например, файлы классов, файлы журналов, файлы результатов, временные файлы данных) создаются динамически, и отслеживать их версии просто бессмысленно. А вот созданные нами артефакты проекта — файлы исходного кода, файлы данных, файлы конфигурации и другие — содержат бизнес-логику приложения. Они должны отслеживаться гитом, поэтому мы их обязательно добавляем в промежуточную область.

Стандартный способ работы с индексом — это добавление или изменение файлов и последующий коммит.

Теперь добавим наш файл file1.txt в индекс с помощью `git add`:

`git add file1.txt`

Важно! Если мы что-то изменили в файле, но не сделали для него `git add`, то он не войдет в текущий коммит. В коммите будет только старая версия файла (до изменений), если таковая имеется.

## Что такое коммит?

**Коммит** — фиксация изменений, внесенных в индекс. Т.е мы всегда сначала добавляем файл с помощью `git add` в индекс и только потом делаем коммит — **снимок текущего состояния изменений, добавленных в индекс**.

Еще говорят, что **коммит** — это единица изменений в проекте. Коммиты можно рассматривать как "безопасные" версии проекта — Git не будет их менять, пока мы явным образом не попросим об этом.

Команда `git commit` делает **коммит.** 

Каждый коммит имеет:

- хэш, например, 549892a096...2184cf57f7 – это уникальный идентификатор коммита, который позволяет в любое время к нему откатиться

- сообщение, например "Added files" (commit message говорит, ЧТО делает коммит, а не КАК делает)

- все индексированные файлы репозитория

- изменения по каждому файлу

- имя автора и время создания коммита.

Команда `git commit` берет все данные, добавленные в индекс с помощью `git add`, и сохраняет их снимок во внутренней базе данных.

Вернемся к нашему файлу. Мы его создали, добавили в индекс, осталось его "закоммитить"  командой: `git commit` и оставить небольшое описание в кавычках (одинарных или двойных — не важно, **важно оставить комментарий**). Комментарий оставляем обязательно, т.к. сделать коммит без него не получится:

`git commit -m 'my first commit, this is Version 1.0'`

Сделать коммит — это значит сделать изменения, собрать эти изменения командой `git add`  и указать коммит-сообщение после ключа "-m" (расшифровывается как "message"). Кстати, старайтесь сразу писать правильные комментарии после  ключа -m: по вашему комментарию к коммиту должно было понять, какие изменения были сделаны. Это также должно помочь новым участникам проекта лучше понять смысл коммитов: надо знать, зачем человек его сделал и какие последствия это вызовет.

Теперь нам останется только запушить наши результаты командой `git push` на удаленный сервер, чтобы другие разработчики тоже имели к ним доступ.  
 