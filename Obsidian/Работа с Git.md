15.04.2023    20:28
Теги: #Программирование #Git 
---
# ***Внутренние ссылки:***
[[Системы контроля версий (VCS)]]
[[Строение GIT]]

1) [[Работа с локальным репозиторием и файлами в GIT и редактирование изменений]]

2) [[Работа с удаленным репозиторием, открытие аккаунта на GitHub, ветвление в GIT]]

3) [[Ветвление в Git]]

4) [[Тэги  в Git]]

5) [[Markdown]]

![[команды в Git Bush.docx]]

---
# ***Внешние ссылки:***
[Курс Степик](https://stepik.org/course/126023/info)
[Владилен Минин GIT](https://www.youtube.com/watch?v=zZBiln_2FhM)
[2.1 Основы Git - Создание Git-репозитория](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-Git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F)
[2.4 Основы Git - Операции отмены](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D1%8B)
[2.5 Основы Git - Работа с удалёнными репозиториями](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D0%BC%D0%B8)
[2.6 Основы Git - Работа с тегами](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%82%D0%B5%D0%B3%D0%B0%D0%BC%D0%B8)
[3.2 Ветвление в Git - Основы ветвления и слияния](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F)
[3.6 Ветвление в Git - Перебазирование](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B1%D0%B0%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
---
# ***Заметка:***

# !Команды!

`git init .` – создает новый репозиторий

`git status` – отображает список измененных, добавленных и удаленных файлов

`git add`  – добавляет указанные файлы в индекс

`git add --all` - добавляет все файлы в индекс

`git reset` – отменяет действие команды git add на файл

`git commit -m` – фиксирует добавленные в индекс изменения с определенным сообщением

`git push` – отправляет изменения на удаленный репозиторий

## Редактирование изменений

`git log` — показывает историю коммитов

`git log -2` — показывает последние 2 коммита

`git log -p` — расширенный вывод истории: выводит то же, что и git log, но еще и с изменениями в файлах

`git log --oneline`  — выводит коммиты в одну строку, показывая только хэш коммита и commit message

`git log --pretty=format:" "` — меняет формат вывода лога в соответствии с указанными в кавычках параметрами

`git show`  — показывает информацию по отдельному коммиту

## Прыгаем по коммитам

`git checkout -- file1.txt` — отменяет изменения в рабочем каталоге, переключает на указанный файл

`git checkout хэш-коммита` — переводит на любой коммит в истории наших изменений

`git diff --staged` — выводит разницу между индексом и последним коммитом

## Отмена коммитов

`git reset` — позволяет удалять коммиты

`git reset``--hard HEAD~2` — используется для удаления двух последних коммитов

`git revert` — используется для обращения изменений, внесенных в коммит из истории проекта.

`git clean`  — используется для операций с неотслеживаемыми файлами.

## Работа с удаленным репозиторием

`git clone https://github.com/kotBantik/mysuperproject1` _—_ клонирует удаленный репозиторий на локальную машину

`git remote add origin https://github.com/kotBantik/something.git` _—_ cвязывает наш локальный репозиторий с удаленным репозиторием   

`git push origin` _—_ отправляет коммиты на сервер

`git remote add origin HEAD` _—_ отправляет на сервер текущую ветку со всеми коммитами, которые мы сделали в ней.

## Ветвление 

`git checkout -b имя-ветки` – создает ветку с указанным именем и автоматически переключает на нее

`git checkout имя-ветки` – автоматически переключает на любую локальную ветку

`git stash` – откладывает изменения, не добавляя их в коммит

`git stash list` – показывает список всех отложенных изменений

`git stash pop` – забирает данные из stash и удаляет их

`git stash apply` – забирает данные из stash, но не удаляет их

`git stash clear` – удаляет все файлы, которые находятся в stash

`git branch -a` – показывает все существующие ветки и в локальном и удаленном репозитории

`git branch -r`  – показывает удаленные ветки на сервере

`git branch` – по умолчанию выводит список локальных веток. С ключами -r, -a можно вывести, соответственно, либо только удаленные ветки, либо все ветки.

`git checkout` – переключает пользователя на другую ветку

`git branch -d имя_ветки` – удаляет ветку, которая полностью слита с какой-то другой веткой

`git branch -D имя_ветки` – удаляет любую локальную ветку

`git push origin --delete имя_ветки` – удаляет ветку с сервера

`git fetch` – стягивает информацию о ветках на сервере к нам на локальную машину.

`git clean -f`  – удаляет все неотслеживаемые файлы

`git clean -fd` – удаляет неотслеживаемые файлы и папки

`git push -u имя_ветки` – создает в удаленном репозитории ветку, соответствующую локальной ветке и обе связывает.

`git cherry-pick 40_символьный_номер_коммита` – позволяет брать коммит с одной ветки и повторять его на другой ветке

# Git – 

это инструмент, который позволяет сразу нескольким людям сохранять и отслеживать изменения в проекте. Git относится к распределенными системам контроля версий: имеет репозиторий не только на сервере, но и локально на компьютерах разработчиков. Вообще репозиторий Git представляет собой каталог файловой системы, в котором находятся файлы конфигурации репозитория, файлы журналов, хранящие операции, выполняемые над репозиторием, индекс, описывающий расположение файлов, и хранилище этих файлов. А по-простому репозиторий **–** это хранилище данных)).

От других систем Git отличается особым подходом к обработке информации: он не записывает отдельно внесенные правки, а делает подробный снимок проекта (snapshot (снэпшот)) в момент сохранения. Он фиксирует состояние каждого файла, и создает ссылку на эту версию.


# Глоссарий

remote **repository**, **master branch и commit**. 

Remote repository – удаленный репозиторий, удаленное хранилище данных.

Master branch – главная ветка, "золотая" ветка, содержащая эталонный код. Ее также называют origin master.

Commit – тот самый коммит – зафиксированное состояние проекта в определенный момент времени; контрольная точка на ветке изменений проекта.

# Краткий пример работы с GIT

1. Создаем у себя копию удаленного репозитория с копией золотой ветки проекта

2. Начинаем работать в этой копии (на локальной ветке). Пишем код, изменяем его.

3. Фиксируем (коммитим) все, что сделали, если хотим поделиться нашим творением – пушим его на удаленный репозиторий. Если не хотим – не пушим)). Закрыли все, выключили компьютер.

4. Решили снова поработать – сначала обновляем нашу локальную ветку до состояния master branch. Для этого командой `git pull` стягиваем к себе все, что другие запушили в удаленный репозиторий. Наши творения никуда не денутся, они так же лежат на нашей локальной ветке, можем продолжать с ними работать, не забывая коммитить.

5. Если нам нужно разработать какой-то новый функционал, то создаем новую ветку под него и работаем в ней. Поработали, закоммитили, посмотрели, что у нас есть две ветки, одна из которых (main) является условно основной. Переключаемся на нее и добавляем этот функционал (делаем слияние веток)


#  Как все происходит.

Имеется удаленный репозиторий (хранилище данных) проекта, который обычно называется origin. Он находится на сервере и является главным хранилищем всего нашего проекта. Из него участники проекта (разработчики, тестировщики, дизайнеры и т.д.) делают копии к себе на локальные компьютеры с помощью определенной команды – `git clone`. 

Удаленный репозиторий (который на сервере) содержит master branch (origin master) – основную ветку с кодом нашего проекта. В ней хранится эталонный код, а саму ветку еще называют "золотой". Этот "клон" тоже будет называться master (или main), но работаем и вносим изменения мы уже именно в нем, в локальной ветке. Золотую ветку (master branch) в удаленном репозитории мы вообще не трогаем.

![[Pasted image 20230416175219.png]]

 Далее каждый разработчик в свою копию вносит какие-то изменения и фиксирует их с помощью команды git commit – комм**и**тит их (в своем локальном репозитории!).

Комм**и**т (commit) – это единица состояния проекта в Git. Коммиты фиксируют состояние проекта (делают snapshot) в определенный момент времени и представляют собой контрольные точки на ветке изменений проекта.

![[Pasted image 20230416175233.png]]

Если разработчики хотят обменяться своим кодом, они могут сделать это через удаленный репозиторий. Сначала они зафиксируют свои изменения в своих репозиториях (“закомм**и**тят”, каждое изменение оформят в виде коммита), потом передадут их на сервер с помощью команды git push (“п**у**шат” свои изменения). Эта команда передает изменения в удаленный репозиторий, и в его истории появятся коммиты:

![[Pasted image 20230416175243.png]]

На удаленном репозитории в master branch встраиваются эти коммиты, ветка растет. В ней сохраняются и наши изменения (коммиты) и изменения других разработчиков, которые тоже закомм**и**тили и зап**у**шили их в удаленный репозиторий.

Для того чтобы нам получить их изменения (ведь в локальной ветке мы имеем только свои изменения), а им наши (у них пока только их изменения. Они – это другие разработчики на проекте), достаточно дать гиту команду `git pull`:

![[Pasted image 20230416175256.png]]

С помощью `git pull` мы "стянем" к себе все, что есть в удаленном репозитории: всю origin master целиком с нашими изменениями и изменениями других разработчиков. Наша master (ветка на локальном компьютере, main-ветка) автоматически обновится до состояния master branch.

Кроме master (main) мы можем создавать другие ветки. Ветка – это альтернативный  путь развития проекта, по сути изменение к какому-то коммиту или разная последовательность коммитов. От любого коммита на master можно создать другую ветку и работать отдельно в ней, а потом соединить с master. Или удалить, если не понадобится.

Ветка всегда имеет свое имя, оно необходимо для ориентирования по веткам. Назовем нашу ветку black:

![[Pasted image 20230416175318.png]]

Опираясь на версию изменений 2.0, с помощью ветки black мы создаем альтернативную историю изменений. Таким образом, у нас есть наша локальная ветка master (та, которую мы склонировали с удаленного репозитория с "золотой" ветки master branch) и альтернативная ветка black. Можем работать и в одной и в другой, продолжать вносить изменения в наш локальный репозиторий на локальную ветку master и при этом отдельно работать с альтернативной веткой black. И если мы захотим поделиться/обменяться веткой black (теми изменениями, которые на ней сделали) с сервером – тоже "зап**у**шим" ее, указав ее название (black).

Мы можем поместить наши изменения в ветке black на какую-то конкретную ветку на сервере, которая будет "выращена" от того же самого коммита на золотой ветке, от которого она была выращена в нашей локальной копии. На рисунке от главной ветки master мы отделили другую ветку, потом все отправили в удаленный репозиторий, где на главной ветке master branch тоже появилась ветка с того же самого коммита:

![[Pasted image 20230416175329.png]]

Допустим, те изменения, что мы сделали на ветке black, нам понравились и мы хотим добавить все это к нашей локальной ветке master. В таком случае делаем новую ревизию и "вливаем" изменения между двумя ветками: в master вольем изменения, которые имеем в ветке black. И дальше можем продолжать историю. Сама операция "слияния" веток выполняется с помощью команды git merge, и называется "смёрживание":

![[Pasted image 20230416175344.png]]

