---

Tags: 
aliases: 
regex-to-search: # "что-то" regex
regex-to-be-found: "NoRgxTBFKey" # "что-то" regex

Тип: конспект
Описание: -

День: 11 # Не трогать!
Месяц: 03 # Не трогать!
Год: 2023 # Не трогать!
дата_создания: 2023-03-11

---
# [[ndarray NumPy]]


## Основные методы ndarray

### Как создать массив

-   `array(object)` — n-мерный массив из любой (возможно, вложенной) последовательности, возвращает объект типа [[ndarray NumPy|`numpy.ndarray` ]]
-   `eye(N, M=N, k=0)` --  двумерный массив с N строками с единицами на диагонали и нулями во всех остальных позициях. Число столбцов M по умолчанию равно N, k — сдвиг диагонали (0 для основной диагонали, положительные числа для верхних диагоналей и отрицательные для нижних),  
-   `zeros(shape)` -- новый массив указанной формы, заполненный нулями,  
-   `ones(shape)` -- новый массив указанной формы, заполненный единицами,  
-   `full(shape, fill_value)` -- новый массив указанной формы, заполненный `fill_value`.

[[Как создать numpy.ndarray из numpy.array]]

### Выделение части массива

- `a[start:stop:step]` выбирает элементы из `a` с индексами от `start` до `stop` с шагом `step`, т.е. `a[start]`, `a[start + step]`, `a[start + 2*step]` и так далее, пока индексы меньше `stop`;
- отрицательные индексы:
	```python
	a = np.array([[1,2,3],[4,5,6],[7,8,9]])
	print(a[-2])
	print(a[-3])

	# [4 5 6]
	# [1 2 3]
	```
- поддерживается синтаксис многоточия: `a[..., 1]` выбирает элементы с любым индексом в первом измерении и с индексом, равным 1, во втором измерении:  `a[:, 1]` оказывается эквивалентно `a[..., 1]`;
- можно указать индексы сразу в нескольких измерениях, указав их через запятую в квадратных скобках (как `a[..., 1]` в примере выше).

### Форма массива

-   `a.flatten()` — превращает массив в одномерный.  
-   `a.T` или `a.transpose(*axes)` — транспонирование (или смена порядка осей в случае, когда размерность массива больше двух).  
-   `a.reshape(shape)` — смена формы массива. Массив "распрямляется" и построчно заполняется в новую форму.

#### a.flatten()

Вызывается методом массива, возвращает новый одномерный массив, созданный из того, который вызвал функцию.

#### a.T или a.transpose(\*axes)

В случае применения `a.transpose()` без аргументов, возвращает матрицу с обратным порядком измерений:

```python
import numpy as np
  
a = np.arange(180)
a = a.reshape(6, 2, 5, 3)
print(a.shape)
  
a = a.transpose()
  
print(a.shape)

###

(6, 2, 5, 3)
(3, 5, 2, 6)
```

Если вы хотите определенным образом траспонировать матрицу, в аргументах введите новый порядок измерений относительно старого следующим образом:

```python
import numpy as np
  
a = np.arange(180)
a = a.reshape(6, 2, 5, 3)
print(a.shape)
  
a = a.transpose(2, 0, 3, 1)
 
print(a.shape)

###

(6, 2, 5, 3)
(5, 6, 3, 2)
```

#### numpy.reshape() или a.reshape()

Может быть вызвана, как через `numpy.reshape()`, так и как метод самого массива.

В первом случае синтаксис таков:

```python
numpy.reshape(array, new_shape_tuple, order="C")
```

`order` - порядок элементов в новом массиве. Обращайтесь к документации для понимания.

Во втором случае таков:

```python
a = numpy.arrange(n)
a.reshape(new_shape_tuple, order="C")
```

Обе функции будут работать, только если произведение измерений изначального массива равно произведению измерений нового.

Функция возвращает новый массив, а не меняет старый.

## Основные методы ndarray

### Базовые статистики

#### a.min(), a.max(), a.mean(), a.std(), a.argmin(), a.argmax()

— **минимум**, **максимум**, **среднее** **арифметическое** и **стандартное отклонение** вдоль указанной оси. По умолчанию ось не указана и статистика считается по всему массиву.

`a.argmin(axis=None)`, `a.argmax(axis=None)` — индексы минимального и максимального элемента

Указав ось, вы рассчитаете функцию вдоль этой оси. "Вдоль оси" означает следующее:

Допустим, вы хотите найти результат функции a.min() в массиве a с формой (4,3,2,2) - это кортеж и это используется в выборе оси.  

Чтобы выбрать ось, в аргументе функции приравняйте axis к индексу оси в кортеже, вдоль которой хотите рассчитать значение функции.

Допустим, мы хотим найти значение функции вдоль оси строк. Тогда мы пишем:
```python
a.min(axis = 0)
```

В оси строк находится четыре элемента, каждый из которых является массивом размера (3, 2, 2). Функция `min()` в случае, когда указана ось, вдоль которой находим минимум, возвращает массив именно такого размера, который содержит элементы, каждый из которых минимален среди оригинальных четырех. 

Можно сказать для наглядности, что функция создаёт массив согласно размеру массивов, соответствующих всем осям, которые не являются осью, вдоль которой рассчитывается функция. В этом массиве каждый элемент является результатом применения функции к списку из элементов, которые находятся на том же месте (тех же индексах), оригинальных массивов, хранящихся в (вдоль) оси, вдоль которой рассчитывается функция.

Аналогично для остальных функций.

#### a.sum(), a.prod()

— сумма и произведение всех элементов вдоль указанной оси.

#### a.cumsum(), a.cumprod()

— частичные суммы и произведения.

Для суммы - каждый элемент массива является суммой текущего элемента с суммой всех предыдущих вдоль выбранной оси. Для произведения аналогично.

### Линейная алгебра

#### Матричное произведение, степень

`a.dot(b)` — матричное произведение двух массивов (размерности должны быть согласованы),
`linalg.matrix_power(M, n)` — возведение матрицы M в степень n,
#### linalg.norm(a, ord=None) - норма

 — норма матрицы a, по умолчанию норма Фробениуса для матриц и L2-норма для векторов; подробное описание возможных норм — в справке,
 
#### Обратная и псевдообратная матрицы

`linalg.inv(a)` — матрица, обратная к a (если a необратима, выбрасывается `LinAlgError`; псевдообратная считается через `linalg.pinv(a)`)

## Общая теория

### Форма массива

У каждого n-мерного массива есть форма. Например, форма матрицы (двумерного массива) из 3 строк и 5 колонок — это (3, 5):
$$\begin{bmatrix} 
. & . & . & . & .\\ 
. & . & . & . & .\\
. & . & . & . & .
\end{bmatrix}$$
форма вектора (вертикального массива) из 10 элементов — это (10, 1):
 $$\begin{bmatrix}
  1\\
  2\\
  3\\
  4\\
  5\\
  6\\
  7\\
  8\\
  9\\
  10
\end{bmatrix}$$
В общем случае форма n-мерного массива — это кортеж (последовательность чисел) из n элементов (n1,…,nk), где ni​ — количество компонент массива в i-м измерении.

Чтобы посмотреть форму массива в NumPy, используется параметр `shape`:

```python
>>> a = np.array([[1,2,3], [4,5,6]])  # создаём массив
>>> print(a)  # смотрим на массив
[[1 2 3]
 [4 5 6]]
>>> a.shape  # смотрим на форму массива
(2, 3)
```

### Арифметические операции с массивами

Для n-мерных массивов соответствующим образом определены основные арифметические и логические операции (`+ - * / // % ** < <= == >= > !=` выполняются поэлементно; если вторым аргументом бинарной операции указано число (скаляр), то он преобразуется в массив той же формы, что и первый аргумент).


> [!info]- Пример
> ```python
> import numpy as np
 >  
> a = np.array([[1,2,3],[4,5,6],[7,8,9]])
> print(a)
>   
> b = a[1, ...]
> c = a[0:3:1, 0:3:1]
> d = a[0:2:1, ...]
>   
> print(b)
> print(c)
> print(d)
 > 
 > # [[1 2 3]
> #  [4 5 6]
> #  [7 8 9]] - print(a)
> # [4 5 6] - print(b)
> # [[1 2 3]
> #  [4 5 6]
> #  [7 8 9]] - print(c)
> # [[1 2 3]
> #  [4 5 6]] - print(d)
>
> ```
> 


## Связано:

```dataview
LIST 
FROM !outgoing([[]])
WHERE regexmatch(this.regex-to-search,regex-to-be-found) or regexmatch(this.regex-to-search, file.name) or regexmatch(this.ключи,regex-to-be-found) or regexmatch(regex-to-search, this.regex-to-be-found)
```
> [!question]- Соурслист
> 1. 


---
#Python/NumPy 

---

[^def]: термин
[^que]: вопрос