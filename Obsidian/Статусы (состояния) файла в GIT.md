20.04.2023    15:28
Теги: #Программирование #Git

---
# ***Внутренние ссылки:***

---
# ***Внешние ссылки:***
[(Подробнее про остальные объекты в Git (дерево, таг, коммит) — можно почитать здесь ]([https://uleming.github.io/gitbook/1_Объектная_модель_git.html](https://uleming.github.io/gitbook/1_%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_git.html) )
)

---
# ***Заметка:***

## Статусы (состояния) файла в Git

**untracked** — неотслеживаемый гитом файл

**unmodified** — неизмененный отслеживаемый гитом файл

**modified** — измененный отслеживаемый гитом файл

**staged** — подготовленный к коммиту отслеживаемый гитом файл


Каждый файл в рабочем каталоге находится в одном из двух состояний: отслеживаемый гитом (он уже о нем знает) и неотслеживаемый. 

Отслеживаемые файлы — это те файлы, для которых **был сделан коммит** (он зафиксирован, для него есть последний снимок состояния в проекте). Они могут быть неизмененными, измененными или подготовленными к коммиту. 

Неотслеживаемые файлы — это любые файлы в рабочем каталоге, которым еще **не делался коммит** и еще не подготовлены к коммиту.

Таким образом, когда мы впервые клонируем репозиторий, все файлы (и папки) будут проходить следующие состояния:

![[Pasted image 20230420153111.png]]

Состояние Untracked имеют все неотслеживаемые файлы и директории. 

Отслеживаемые файлы, как уже было сказано выше, могут находится в 3 состояниях: неизмененный отслеживаемый (Unmodified), измененный отслеживаемый (Modified) и подготовленный для фиксации в коммит (Staged).

Когда мы с помощью команды `git add` добавляем неотслеживаемый файл, то он переходит в состояние Staged и начинает отслеживаться гитом:

Untracked     `>`    Staged

Если у нас файл уже отслеживается гитом (в состоянии Unmodified) и мы его изменяем — добавляем строчки, удаляем что-то и т.д. — то он переходит в состояние "измененный отслеживаемый":

Unmodified   `>`   Modified

В этом состоянии Git продолжает осуществлять контроль над всеми сделанными в этом файле изменениями, просто файл не будет добавлен в следующий коммит. 
Статус Modified показывает, что файл имеет историю в системе Git и был изменен относительно его последнего состояния. Если мы теперь сохраним наш измененный файл, то он переходит в состояние Staged:

Modified    `>`    Staged

Если мы делаем коммит файла, который находится в состоянии Staged, он переходит в состояние Unmodified (неизмененный отслеживаемый):

Staged    `>`   Unmodified

Весь цикл можно представить следующим образом: мы изменяем файл, сохраняем его в индексе и делаем коммит, а потом все сначала  

Unmodified    `>`   Modified   `>`   Staged    `>`   Unmodified

## Практический пример статусов файлов

Вернемся в нашу папку my-project, в которой уже есть один файл file1.txt. Создадим еще один файл file2.txt и видим, что у нас имеются 2 неотслеживаемых файла (Untracked):

![[Pasted image 20230420152942.png]]

Для того, чтобы сделать файл отслеживаемым, мы сначала используем команду `git add`.  (команды `git add *` и `git add .` добавляют **все** файлы)

Если теперь мы посмотрим его статус с помощью `git status`, то увидим, что они подсвечиваются зеленым и для Git они **new**, т.е. гит их для себя пометил как отслеживаемые, но они пока не имеют истории (мы ничего в них не изменяли):

![[Pasted image 20230420152950.png]]

Файлы были в статусе Untracked (только что созданы и еще не отслеживаются гитом), в выводе команды git status они приняли состояние New, значит, что они перешли в статус Staged:

Untracked   (git add)          `>`       Staged

![[Pasted image 20230420153003.png]]

Теперь Git видит их. Разберем на примере файла file1.txt, что сделал Git, когда мы задали команду `git add`?

**1. Git взял файл file1.txt, создал для него новый объект, добавил его в папку оbjects каталога .git в свою базу данных и дал ему имя** — т.е. сохранил его как блоб-файл 

Все файлы ссылаются друг на друга с помощью 40-значного SHA-1 — уникального идентифицирующего хэша (контрольной хэш-суммы содержимого и заголовка объекта), его можно посмотреть в репозитории:

![[Pasted image 20230420160532.png]]

Эта 40-значная строка (у вас скорее всего будут другие цифры-буквы)  ![](https://ucarecdn.com/1e6e01f5-5f14-4e1d-9ca3-0a93b26bee6a/)  и есть единица хранения файла file1.txt с именем ![](https://ucarecdn.com/1e6e01f5-5f14-4e1d-9ca3-0a93b26bee6a/). Первые 2 символа определяют подкаталог файла (27), остальные 38 — имя. Данный объект ![](https://ucarecdn.com/98a0cbae-bc41-4b52-aea7-26a7e9ca8f40/) хранит снимок содержимого файла file1.txt.  Git создал директорию .git/objects/27 и сохранил в нее блоб-файл с именем 703ec79a98c1d097d5b1cd320befffa376e826

Получить обратно содержимое объекта можно командой `cat-file`   с ключом `-p`, который означает автоматическое определение типа содержимого и вывод содержимого на печать в удобном виде:

![](https://ucarecdn.com/1f74cf7b-ca27-4c5e-8159-39b49a498756/)

Простое добавление файла в Git приводит к сохранению его содержимого в папке objects.

Повторив в своем теримнале указанные выше действия несколько раз, вы научитесь добавлять данные в Git и извлекать их обратно.

**2. Добавил имя сохраненного blob-файла в индекс.**

Мы помним, что в папке `.git/index` гит хранит список файлов, за которыми он следит. Каждая строчка состоит из имени файла и его хэша. Вот таким получилось содержимое файла file1.txt в `.git/index`:

![](https://ucarecdn.com/67e8fce1-d023-46a8-8aa7-5a4d5ef4ce72/)

**Выполним следующее задание:**

1. Создадим еще один файл num.txt с содержимым ffffff:

`echo "ffffff" > num.txt`

2. Добавим его в индекс и посмотрим статус. 


3. Изменим содержимое файла num.txt  с ffffff на aaaaaa с помощью команды для редактирования: `nano имя.txt` 

Можно и без nano, а с помощью уже знакомой нам ранее команды `echo`. Командой `echo "тра-ля-ля" > sss.txt` мы создаем файл sss.txt, в котором будет текст "тра-ля-ля". Этой же командой мы можем изменить "тра-ля-ля" на "пам-па-рам" в файле sss.txt :`echo "пам-па-рам" > sss.txt`. Теперь у нас в файле sss.txt изменилось содержимое.

`nano имя.txt`— команда откроет консольный текстовый редактор nano для изменения содержимого файла. Чтобы сохранить изменения и выйти из редактора nano, надо нажать **Ctrl+X**.

Итак, заходим в nano, меняем содержимое файла, выходим с помощью **Ctrl+X** и теперь посмотрим статус снова.

Будет примерно так:

![[Pasted image 20230420153018.png]]

4. Не совсем)), файл num.txt одновременно находится в двух состояниях: staged (у него ведь еще состояние new) и modified. 

Сейчас разберемся, как такое возможно)

Когда мы изменили содержимое файла num.txt  с ffffff на aaaaaa, вместе с этим поменялась и хэш-сумма. Git это заметил, и предупредил нас: состояние modified не проиндексировано:

`Changes not staged for commit`

Если мы сейчас сделаем коммит, то в него попадет файл num.txt со значением ffffff, а не aaaaaa. Чтобы в коммит попали новые изменения, нам нужно заново проиндексировать файл num.txt (добавим новые изменения файла в индекс):

`git add num.txt`

Происходит    Unmodified  `>`  Modified   и  затем   Modified `>` Staged:

![[Pasted image 20230420153111.png]]

Убедитесь, что num.txt теперь тоже в staged:
![[Pasted image 20230420161755.png]]
Кстати, кроме файлов в Git можно добавлять и папки. Чтобы добавить новую директорию в гит, надо добавить хотя бы один файл из этой директории в Git.