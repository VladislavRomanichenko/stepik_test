24.04.2023    22:34
Теги: #Git 
---
# ***Внутренние ссылки:***

---
# ***Внешние ссылки:***

---
# ***Заметка:***

# Команды

`git checkout -b имя-ветки` – создает ветку с указанным именем и автоматически переключает на нее

`git checkout имя-ветки` – автоматически переключает на любую локальную ветку

`git stash` – откладывает изменения, не добавляя их в коммит

`git stash list` – показывает список всех отложенных изменений

`git stash pop` – забирает данные из stash и удаляет их

`git stash apply` – забирает данные из stash, но не удаляет их

`git stash clear` – удаляет все файлы, которые находятся в stash

`git branch -a` – показывает все существующие ветки и в локальном и удаленном репозитории

`git branch -r`  – показывает удаленные ветки на сервере

`git branch` – по умолчанию выводит список локальных веток. С ключами -r, -a можно вывести, соответственно, либо только удаленные ветки, либо все ветки.

`git checkout` – переключает пользователя на другую ветку

`git branch -d имя_ветки` – удаляет ветку, которая полностью слита с какой-то другой веткой

`git branch -D имя_ветки` – удаляет любую локальную ветку

`git push origin --delete имя_ветки` – удаляет ветку с сервера

`git fetch` – стягивает информацию о ветках на сервере к нам на локальную машину.

`git clean -f`  – удаляет все неотслеживаемые файлы

`git clean -fd` – удаляет неотслеживаемые файлы и папки

`git push -u имя_ветки` – создает в удаленном репозитории ветку, соответствующую локальной ветке и обе связывает.

`git cherry-pick 40_символьный_номер_коммита` – позволяет брать коммит с одной ветки и повторять его на другой ветке

# Ветвление в Git

Есть негласное правило – никогда не делать коммиты сразу в master, кроме первого коммита. В master по сути делаются только merge, а не коммиты.
![[Pasted image 20230424224300.png]]

При создании ветки в нее автоматически копируются все коммиты, которые были в master. 

![[Pasted image 20230424224307.png]]
А ветку fixing после слияния с master обычно удаляют.

По логике ветка – это последовательность коммитов, которые идут друг за другом в хронологической последовательности:
![[Pasted image 20230424224315.png]]
На этом рисунке мы видим 3 ветки – **main**, **develop** и **feature**, они не пересекаются: работа в ветках идет параллельно.

С точки зрения внутренней реализации Git, ветка – это ссылка на последний коммит в этой ветке:

![[Pasted image 20230424224326.png]]
Ветка **main** – это последовательность коммитов C1, C8, C9 и C10, она указывает на коммит, который является последним в данной ветке – Git поставил себе указатель HEAD над коммитом C10. Для ветки **develop** последним коммитом является C11, а последним коммитом ветки **feature** является C7.

Git использует HEAD как ссылку на текущую ветку. При переключении между ветками проекта происходит переключение HEAD на указанную ветку.  

# Создание веток 

Создать свою ветку можно двумя способами:

1. Команды `git branch` + `git checkout`

Это классический вариант создания ветки: сначала создаем ветку командой `git branch имя_ветки`, потом переходим на нее `git checkout имя_ветки`

2. Команда `git checkout -b`

Команда `git checkout` умеет создавать ветки и сразу переключаться на них. Это намного удобнее, чем в первом способе: сначала создавать ветку, потом на нее прыгать. Поэтому второй способ является более популярным, так как задействует только одну команду `git checkout` со специальным ключом `-b` (означает ветку – branch).

Внутри Git при создании ветки выполняет следующие шаги:

1) в папке .git\ refs\ heads он создает новый файл и дает ему имя ветки, которую мы хотим создать (при условии, что такого файла не существует). Например, если мы выполним команду `git branch test`, то создастся файл *.git\ refs\ heads\ test.

2) в этот файл записывается хэш текущего коммита. С него ветка и начнется.

Важно понимать, что как только мы создали новую ветку, она указывает на тот же коммит, что и основная ветка, и HEAD. Визуально это выглядит так:

![](https://ucarecdn.com/4cb6b72b-6bc5-470c-b4f8-0d8bfdf4bbf2/)

Git создаст тот же самый коммит, с которого пойдет новая ветка **test**. Мы можем параллельно вносить изменения и в ветке А и в ветке **test**, причем эти изменения не будут пересекаться.

Переключиться на любую локальную ветку можно с помощью команды `git checkout имя-ветки`.

Когда мы ее задаем, Git сначала проверит, существует ли указанная ветка, затем переключит указатель HEAD на новую ветку и меняет рабочий каталог так, чтобы он соответствовал этой новой ветке. Ведь рабочие копии на разных ветках могут отличаться, поскольку ветки работают независимо друг от друга. То есть сначала Git смотрит на последний сделанный в данной ветке коммит, а потом восстанавливает структуру и файлы в рабочей копии:

- добавляет файлы, которые есть в новом коммите, но которых нет в коммите, с которого мы переключились

- удаляет файлы, которые были в коммите, с которого мы переключились, но которых нет в новом коммите

- игнорирует (но не удаляет) файлы, которых нет ни в одном из этих двух коммитов.

Выполнив эти три условия для всех файлов в рабочей копии, Git полностью переключит нас на нужную ветку.

## Перемещение по веткам

Существует команда просмотра списка веток – уже знакомая нам `git branch`, но с другими ключами.

Итак, чтобы посмотреть, на какой ветке мы работаем, применяем команду `git branch`. Она также покажет локальные ветки, которые есть в текущей рабочей копии (рабочем каталоге).

`git branch -r`  покажет удаленные ветки на сервере, а если вообще хотим посмотреть все существующие ветки и в локальном и удаленном репозитории, то к команде добавляем ключ `-a` (означает, что все – all): `git branch -a`.

## git stash

Допустим, у нас 2 ветки – **test** и **A** – и мы работаем в ветке **test**. Делаем в ней какие-то изменения, но пока их не коммитим – а вдруг не пригодятся?

 Поэтому есть два варианта решения проблемы:

1) добавляем все изменения в коммит и меняем ветку

2) откладываем изменения, не добавляя их в коммит, воспользовавшись командой `git stash`. Эта команда позволяет запомнить изменения, которые были на текущей ветке и мы можем спокойно перейти на другую ветку.

`git stash` спрячет наши изменения в некоторый внутренний стек Git.  Каждое применение `git stash` создает отдельный коммит, хэш которого и записывается в стек. Поэтому с помощью этой команды можно неограниченное количество раз откладывать изменения.

Рассмотрим подробнее варианты применения `git stash`.

1) Если мы не добавляли файл в индекс (а как мы помним, по умолчанию гит не берет не проиндексированные файлы), тогда нам нужно добавить сначала файл в индекс или к команде `git stash` добавить `-u` (полный вариант  `--include untracked`). Такая запись означает, что мы добавляем в `stash` все файлы, которые имеем, включая не проиндексированные.

- смотрим список всех отложенных изменений командой `git stash list`,

- достаем изменения из стека и возвращаем их в рабочую копию командой `git stash pop` или `git stash apply`. Первая команда забирает данные из `stash` и удаляет их оттуда, а вторая забирает, но не удаляет.

2) Если мы добавляли файл в индекс, то достаточно просто команды `git stash`

Если мы захотим удалить все файлы, которые находятся в stash, то используем `git stash clear`.

# Слияние веток

 `git merge test`.

Важно! В merge указывает ту ветку, на которой работаем и которую хотим соединить с главной. Мы работали в **test**, значит ее и указываем. Команда `git merge` автоматически смерживает указанную ветку с main.

Но если мы не проверили, на какой ветке сидим, например, в этот момент мы находились на ветке **A**, а не на ветке **test** (но мёржим-то ветку test), то произойдет следующее. Git создаст ревизию – ссылку на объект git, по сути еще один коммит. В литературе встречается термин "ревизия", который означает то же самое, что и "коммит", хотя коммит – это фиксация одного из объектов git (блоб, дерево, теги), а ревизия является способом ссылки на объект git.

Так вот, эта ревизия будет содержать исходную ветку **A** и изменения, которые мы сделали в ветке **test**:

![[Pasted image 20230424225837.png]]
После создания ветку можно отправить на сервер с помощью команды `git push origin имя-ветки`.  Там она попадает в наш удаленный репозиторий. И потом ее снова нужно смержить, но уже с "золотой" веткой.

Еще момент. Допустим, мы хотим запушить ветку, которую мы создали у себя локально и которой еще нет в удаленном репозитории. Тогда в ответ на команду `git push origin` гит нам скажет в комментарии, что на гитхабе-то такой бранчи нет еще. А заодно даст подсказку, как это подправить:

`git push --set-upstream origin имя_ветки`

На нашем удаленном репозитории на гитхабе создастся эта бранча. Перейдя в репозиторий на гитхабе, мы увидим, что добавилась эта новая ветка с нашим локальным репозиторием и теми файлами, которые мы в нем насоздавали.

На сервере с помощью команды `git merge имя_ветки` наша ветка соединится с веткой проекта master branch, причем добавлять название origin здесь уже не нужно. Процесс смерживания веток автоматически выполняется с аккаунта на гитхабе, куда мы в свой удаленный репозиторий сначала запушили ветку.

Важно! Команда  `git push origin имя_ветки` – отправляет нашу ветку на сервер в удаленный репозиторий проекта на гитхаб, а уже там команда `git merge имя_ветки` – сливает нашу ветку с главной веткой в удаленном репозитории.

Мы также можем забрать себе на компьютер ветку с удаленного репозитория командой:

`git checkout origin/имя-ветки -b имя-ветки`

После работы в локальном репозитории могут оставаться различные ненужные (=неотслеживаемые) файлы. Чтобы удалить все лишнее, используем команду `git clean -f`  для удаления всех untracked файлов или `git clean -fd` для удаления и файлов и папок.

## Конфликты при слиянии веток

Бывает так, что при заливке проекта в пустой репозиторий на гитхаб после ввода команды `git push` мы можем увидеть следующую ошибку: "fatal: the current branch has no upstream branch". Это ошибка говорит о том, что гит не может решить вопрос аутентификации, потому что мы забыли добавить параметр `-u` при пуше в первый раз. Поэтому действуем так:

`git push -u origin имя_ветки`

Данной командой мы создаем в удаленном репозитории ветку, соответствующую нашей локальной и связываем их: в удаленную ветку будет производиться push из локальной ветки, а из удаленной ветки будет производиться pull в локальную ветку.

Опять же, это актуально, только если мы пушим в пустой репозиторий. Если клонировали – то соответствие ветвей автоматически настроено. А вот как только мы создадим новую локальную ветвь и захотим ее запушить на удаленный репозиторий, нам понадобится ключ `-u`. Кстати, можно выбрать другое имя для создаваемой ветки на удаленном репозитории, просто вместо названия текущей ветки указать любое другое:

`git push -u origin любое_другое_имя_ветки`

Иногда используют команду `git merge --abort`, чтобы откатить состояние до того, что было до запуска слияния.

## Удаление веток

Для того, чтобы удалить какую-то ветку, используем команду `git branch` с ключом **-d** (означает delete – удалить) и прописываем название удаляемой ветки:

`git branch -d имя_ветки`

Ветка будет удалена только если она полностью слита с какой-то другой веткой. В противном случае гит не даст нам ее удалить.

Бывает так, что мы создали какую-то ветку, сделали в ней коммит, но потом поняли, что нам не нравится, не хотим ее мержить. Чтобы удалить эту локальную ветку, надо перейти на master (`git checkout master`) и стереть ее там:

`git branch -D имя_ветки`

В отличии от ключа **-d** ключ **-D** (тоже (означает delete) удалит ветку в любом случае, даже если в ней есть изменения, которые мы можем потерять. Останется только master.

А чтобы удалить ветку с сервера, надо выполнить пуш ветки, только с флагом `--delete`:

`git push origin --delete имя_ветки`

Кстати, ведь мы в проекте не одни, в нем будут постоянно появляться новые ветки. Чтобы их увидеть, сначала нужно выполнить команду `git fetch`. Она сходит на сервер и проверит, что там есть нового. Напомним, что эта команда не создает локальные ветки, она просто подтягивает информацию о них. Например, команда: `git fetch origin some_branch` скачает нам ветку **some_branch** из удаленного репозитория, если таковой у нас нет локально.

## Кое-что о команде git cherry-pick

`git cherry-pick` позволяет брать коммит с одной ветки и повторять его на другой ветке.

Создадим от ветки master другую ветку **new**, в которой создадим 3 файла (_1.txt_, _2.txt_ и _3.txt_) и закоммитим эти изменения:

![](https://ucarecdn.com/07f30766-1621-4610-8b96-7d98da7d58a2/)

Из всех этих коммитов нам понравился второй, с сообщением "2th commit", решаем его взять из этой ветки **new** и добавить на ветку master. Для этого берем хэш этого коммита. Мы уже знаем, как посмотреть хэш коммита – командой `git log` отобразим список всех коммитов. Смотрим, копируем номер нужного нам коммита и переходим на ветку master, т.к. цель – добавить коммит в нее. С master вызываем команду `git cherry-pick` и вставим скопированный хэш.

## Как проходит pull request и merge

C помощью запросов `pull` мы уведомляем участников команды о том, что поработали на конкретной ветке и подготовили некий функционал, который требуется проверить, а затем выполнить слияние с главной веткой. Т.е., создавая **pull request** (пулл-реквест), мы всего лишь **просим** другого разработчика (например, человека, занимающегося поддержкой проекта) **забрать** ветку из нашего репозитория в его репозиторий.

Для создания пулл-реквеста необходимо указать 4 параметра:

- исходный репозиторий,

- исходную ветку,

- репозиторий назначения,

- ветку назначения.

Давайте по порядку рассмотрим практический пример использования pull-request в рабочем процессе с форками (о форках мы говорили на 4 уроке модуля 4.2).:

1) мы поработали в отдельной ветке в своем локальном репозитории

2) затем отправляем свою ветку в удаленный репозиторий на GitHub (или другой сервис) командой `push`

3) там же на гитхабе создаем запрос `pull`

4) наши модификации проверяются, обсуждаются, если нужно — возвращаются нам обратно для правки

5) человек, занимающийся поддержкой проекта, смерживает (сливает) нашу ветку в официальный репозиторий и закрывает запрос.

У нас на проекте есть свой публичный репозиторий — исходный, соответственно и своя ветка — исходная ветка — та, что содержит наши изменения. Когда мы предлагаем слить нашу ветку с основной базой кода, то официальный репозиторий проекта является репозиторием назначения (целевой репозиторий), а целевой веткой — главная ветка main, "золотая ветка". Кроме того, мы можем посылать пулл-реквесты нашим коллегам за пределами официального репозитория проекта. Например, если мы работаем над какой-то веткой вместе с другим разработчиком, то можем создать пулл-реквест, указав в качестве целевого репозитория не официальный репозиторий проекта, а публичный репозиторий нашего коллеги. Тогда в качестве исходной ветки и ветки назначения мы просто укажем одну и ту же ветку (в которой работаем).

Итак, мы форкаем репозиторий PM'а на гитхабе, клонируем его на свой локальный компьютер, видим там главную ветку, например она называется **some-branch**, создаем от нее свою ветку **some-feature** и работаем в ней:

![](https://ucarecdn.com/d2091133-394e-4780-8d34-d05e7ce50843/)

Делаем сколько угодно коммитов на нашей ветке, а закончив свою задачу, помещаем ветку **some-feature** в собственный репозиторий на гитхабе (не в официальный репозиторий проекта) с помощью простой команды `git push`:

`git push origin some-branch`

Теперь наши изменения будут доступны человеку, занимающемуся поддержкой проекта (или любым другим участникам, которым может понадобиться доступ к этим изменениям). После добавления своей ветки в гитхаб, мы из своего же аккаунта создаем пулл-реквест, перейдя в свой репозиторий, созданный с помощью форка, и нажав на кнопку _Pull request_ в верхнем правом углу. Отобразится форма, в которой наш репозиторий автоматически будет указан в качестве исходного. Нам нужно только указать исходную ветку (**some-branch**), целевой репозиторий и ветку назначения — главную ветку main и ввести заголовок и описание пулл-реквеста. После нажатия на кнопку `Сreate pull request` нашему PM'у придет уведомление. Он видит все созданные другими членами команды пулл-реквесты в своем репозитории. Нажав на наш пулл-реквест, он увидит его описание, историю коммитов нашей ветки и все изменения в пулл-реквесте.

Если PM считает функционал готовым к слиянию с проектом, ему достаточно нажать кнопку _Merge_ (Слияние), чтобы одобрить запрос pull и выполнить слияние нашего функционала со своей веткой main.