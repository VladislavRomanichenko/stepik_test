05.05.2023    15:46
Теги: #Python/NumPy 
---
# ***Внутренние ссылки:***

---
# ***Внешние ссылки:***
[Инфо сайт](https://proproprogs.ru/)
[Doc](https://numpy.org/doc/stable/reference/arrays.ndarray.html)
---
# ***Заметка:***

#  Фундаментальный элемент NumPy – массив (array)

В NumPy элементы массива имеют единый тип данных.

Их индексы описываются кортежем целых неотрицательных чисел. 
Размерность кортежа – это ранг массива (то есть, размерность массива), а каждое число в кортеже представляет свою отдельную ось:

![[Pasted image 20230507225246.png]]

```python
numpy.array(object, dtype=None, …)
```

Здесь в качестве первого параметра object может выступать список или кортеж, а также функция или объект, возвращающий список или кортеж.
Второй параметр dtype – это тип элементов массива. Если указано значение None, то тип будет определяться автоматически на основе переданных данных. 

```python
a = np.array([1, 2, 3, 4])
```

Какой будет тип у этих элементов? Мы можем его посмотреть с помощью атрибута dtype, выполнив в консоли строчку:

```python
a.dtype
```

```
int32
```

# Основные типы данных. Создание массивов.

## Типы данных и словарь sctypeDict
Если же нам явно нужно указать тип элементов массива, то его можно записать вторым аргументом, например, так:

```python
a = np.array([1,2,3,4], 'float64')
```

В результате все величины будут вещественными 64-битными числами.

И здесь сразу возникает вопрос: какие типы данных поддерживает пакет NumPy. Их огромное количество и посмотреть можно с помощью словаря

```python
np.sctypeDict
```

![[Pasted image 20230507225701.png]]

Каждый из перечисленных типов можно указывать или в виде строки у параметра dtype (который имеется у многих функций пакета NumPy), например, так:

```python
a = np.array([1,2,3,4], 'uintc')
a = np.array([1,2,3,4], 'str_')
```

Или использовать как самостоятельный объект:

```python
a = np.array([1, 2, 5000, 1000])
b = np.complex64(a)
```

Получим :

```python
array([1.e+00+0.j, 2.e+00+0.j, 5.e+03+0.j, 1.e+03+0.j], dtype=complex64)
```

то есть, с их помощью можно выполнять преобразование типов. 
Самостоятельное указание типов следует с определенной осторожностью, так как это может привести к потере данных и их некорректному представлению. Например, вот такая строка:

```python
a = np.array([1, 2, 5000, 1000], dtype='int8')
```

создаст массив с типом int8 (однобайтовое целое число), но данными:

```python
array([ 1, 2, -120, -24], dtype=int8)
```

Потому что значения 5000 и 1000 не умещаются в однобайтовое целое число, поэтому видим значения -120 и -24.

## Создание массивов с помощью функции array

```python
np.array( (1, 2, 3) )
```

Или можно сформировать список с использованием инструмента listcomprehensions:

```python
def getList():
    for i in range(10):
        yield i
```
 
```python
a = np.array( [x for x in getList()] )
print(a)
```
Здесь в качестве итератора используется функция-итератор getList(). Но если передать строку:

```python
np.array( "Hello" )
```

то получим массив из одного элемента:

```python
array('Hello', dtype='<U5')
```

Строки не разбиваются на символы, так как элементами массива выступают только элементы списка или кортежа.

## Объявление многомерных массивов

Предположим, требуется определить матрицу, размерностью 3x2 элемента. Это можно сделать так:

```python
a = np.array([[1, 2], [3, 4], [5, 6]])
```

То есть, мы передали двумерный список и он был преобразован в двумерный массив. В консоли увидим следующее его отображение:

```python
array([[1, 2],  
       [3, 4],  
      [5, 6]])
```

Но, если указать не прямоугольный двумерный список, например, так:

```python
a = np.array([[1, 2], [3, 4], [5, 6, 7]])
```

то при создании двумерной матрицы будет выдана ошибка. Матрицы должны содержать определенное число столбцов и строк, то есть, быть прямоугольной таблицей чисел. Здесь же мы передаем третьей строкой список из трех элементов и это приводит к ошибке.

Далее, если требуется объявить трехмерную матрицу, то это будет выглядеть уже так:

```python
b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])
```

И при ее выводе в консоли увидим следующее:

```python
array([[[ 1,  2],  
[ 3,  4]],  
[[ 5,  6],  
[ 7,  8]],  
[[ 9, 10],  
[11, 12]]])
```

То есть, у нас здесь в основном списке перечислены двумерные списки и все это преобразуется в трехмерный массив.

## Расположение осей многомерного массива

Вдоль первой оси (axis0) для трехмерного массива будут располагаться двумерные срезы (матрицы), а остальные две оси (axis1 и axis2) будут определять строки и столбцы этих двумерных матриц:

![[Pasted image 20230507230010.png]]

Например, выполнив в консоли команду

```python
b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])

b[0]
```

увидим первый двумерный срез трехмерного массива:

```python
array([[1, 2],  
[3, 4]])
```

Если указать первые два индекса:

```python
b[0, 0]
```

то увидим первую строку первого среза:

```python
array([1, 2])
```

Наконец, указав все три индекса:

```python
b[0, 0, 0]
```

получим первый элемент трехмерной матрицы:

```python
1
```

Если размерность массива увеличивается до четырех, пяти и так далее осей, то принцип индексирования сохраняется: мы также указываем требуемый индекс элемента в виде кортежа чисел:

(x1, x3, x3, …, xN)

где местоположение каждого числа определяет ось, по которой берется тот или иной индекс.

# Функции автозаполнения, создания матриц и числовых диапазонов

## Функции автозаполнения элементов массива  (empty, eye, identity, ones, zeros, full)

![[Pasted image 20230507232041.png]]


```python
np.empty(10) # создание одномерного массива с произвольными числами
np.empty(10, dtype='int16')
np.empty((3, 2), dtype='float32') # возвращаетматрицу 3x2 стипомfloat32
```

Для функций eye и identity размерности указываются отдельными параметрами:

```python
np.eye(4)    # матрица 4х4
np.eye(4, 2)         # матрица 4x2
np.identity(5) # матрица 5x5
```

Функции ones, zeros и full работают по аналогии с функцией empty:

```python
np.zeros( (2, 3, 4) ) # нулевая матрица размерностью 2x3x4
np.ones( [4, 3], dtype='int8') # матрица 4x3 из единиц и типом int8
np.full((3, 2), -1) # матрица 3x2, состоящая из -1
```

Все эти функции работают быстрее, чем функция array с генератором списков языка Python. Поэтому их предпочтительно использовать при создании и инициализации массивов определенными значениями.

## Функции создания матриц (mat, diag, diagflat, tri, tril, triu, vander)

Следующий полезный набор функций позволяет генерировать матрицы на основе списков или по определенным правилам.

![[Pasted image 20230507232107.png]]

Давайте посмотрим как работают эти функции.

```python
np.mat('1 2 3 4') # создает матрицу 1x4 из строки
np.mat('1, 2, 3, 4') # то же самое: создает матрицу 1x4 из строки
np.mat('1 2; 3 4') # возвращает матрицу 2x2
```

Или же, вместо строк можно использовать список или кортеж:

```python
np.mat([5, 4, 3])
np.mat( [(1,2,3), (4,5,6)])
```

Но, если из переданных данных нельзя сформировать прямоугольную таблицу (матрицу), то произойдет ошибка:

```python
np.mat( [(1,2,3), (4,5,6,7)])# ошибка, размерности не совпадают
```

Следующая функция позволяет формировать диагональные матрицы:

```python
np.diag([1, 2, 3]) # диагональная матрица 3x3
```

Но, если ей передать двумерный список, то она возвратит одномерный массив из элементов, стоящих на главной диагонали:

```python
np.diag([(1,2,3), (4,5,6), (7,8,9)]) # выделение элементов главной диагонали
```

Если же мы хотим сформировать диагональную матрицу из многомерных списков или массивов, то следует воспользоваться функцией

```python
np.diagflat([(1,2,3), (4,5,6), (7,8,9)])
```

Следующий набор функций используются для формирования треугольных матриц. Например:

```python
np.tri(4) # треугольная матрица 4x4
np.tri(4, 2) # треугольная матрица 4x2
```

Если нужно привести уже существующие матрицы к треугольному виду, то это можно сделать так:

```python
a = np.array( [(1,2,3), (4,5,6), (7,8,9)] )
np.tril(a) # нижняя треугольная матрица размером 3x3
np.triu(a) # верхняя треугольная матрица размером 3x3
```

Если указать одномерный список:

```python
np.tril([1,2,3])
```

то будет создана треугольная матрица 3x3 из строк [1, 2, 3].

Также функции tril и triu будут работать и с многомерными массивами:

```python
np.tril([[[1,2,3], [4,5,6], [7,8,9]]])
np.tril([[[1,2,3], [4,5,6], [7,8,9]], [[10,20,30], [40,50,60], [70,80,90]], [[100,200,300], [400,500,600], [700,800,900]]])
```

В этом случае последние двумерные сечения будут приведены к треугольному виду.

Последняя функция этойгруппы формирует матрицу Вандермонда из одномерных списков или массивов:

```python
np.vander([1,2,3]) # матрица Вандермонда 3x3
```

## Функции формирования числовых диапазонов, одномерных массивов (arange, linspace, logspace, geomspace, meshgrid, mgrid, ogrid)

```python
range(Start, Stop, Step)
```

которая генерирует числовой диапазон с параметрами Start, Stop, Step. Причем, все эти параметры должны быть целочисленными. В NumPy есть подобные функции, но более гибкие и работающие с ***вещественными величинами.***

![[Pasted image 20230507232134.png]]

Первая функция arrange довольно часто применяется в программах на Python. Она позволяет проходить заданный интервал с указанным шагом, например, так:

```python
np.arange(5)# интервал [0; 5) с шагом 1
np.arange(1, 5)# интервал [1; 5) с шагом 1
np.arange(1, 5, 0.5) # интервал [1; 5) с шагом 0,5
```

Обратите внимание, в отличие от функции range языка Python в arrange пакета NumPy можно указывать вещественные значения. Вот еще один пример, демонстрирующий это:

```python
np.arange(0, np.pi, 0.1)
```

Здесь все величины вещественные. Мы начинаем движение от значения 0 с шагом 0,1 пока не дойдем до значения пи (не включая его). И, далее, используя этот массив, можно вычислить синус или косинус от всех этих значений:

```python
np.cos(np.arange(0, np.pi, 0.1))
```

Видите, как это удобно. Без пакета NumPy нам пришлось бы писать цикл и делать вычисление для каждого значения аргумента. А здесь мы сразу получаем готовый массив значений функции косинуса. Это работает гораздо быстрее циклов в Python.

Похожим образом работает и функция linspace. Она разбивает указанный интервал на равномерные отрезки и возвращает массив этих значений:

![[Pasted image 20230507232148.png]]

Мы указываем в качестве аргументов интервал [start; stop] и число отметок в этом интервале n. Если n = 0, то получим пустой массив. При n = 1 – значение start. При n = 2 – значения start и stop. При n> 2 равномерное разбиение интервала точками m = n-2. Например:

```python
np.linspace(0, np.pi, 0) # пустой массив
np.linspace(0, np.pi, 1) # одно значение 0
np.linspace(0, np.pi, 2) # два значения: 0 и pi
np.linspace(0, np.pi, 3) # три значения: 0, pi/2, pi
```

В linspace мы задаем граничные значения и число делений, а шаг вычисляется автоматически.

Функции logspace и geomspace работают аналогичным образом. У них указываются граничные значения и число членов, а на выходе имеем массив из соответствующих величин. Например:

```python
np.logspace(0, 1, 3) # значения: 1, sqrt(10), 10
np.logspace(0, 1, 4) # значения: 1, 2.15, 4.64, 10
```
 
```python
np.geomspace(1, 4, 3) # значения: 1, 2, 4
np.geomspace(1, 16, 5) # значения: 1, 2, 4, 8, 16
```

## Функции формирования массивов на основе данных, файлов (array, asanyarray, ascontiguousarray, asmatrix, copy, frombuffer, fromfile, fromfunction, fromiter, fromstring, loadtxt)

Рассмотрим следующую группу, связанную с формированием на основе уже имеющихся данных.

![[Pasted image 20230507232208.png]]

Работа этих функций вполне очевидна, рассмотрим только некоторые из них. Функция copy выполняет копирование массива. Например, имеется массив:

```python
a = np.array( [(1, 2), (3, 4)] )
```

И создать его копию в памяти устройства, можно так:

```python
b = np.copy(a)
```

В этом легко убедиться, если вывести id этих объектов:

```python
print(id(a), id(b))
```

Формирование массива с помощью функции выполняется следующим образом:

```python
def getRange(x, y):
    return 100 * x + y
```
 
```python
a = np.fromfunction(getRange, (2, 2))
print(a)
```

Обратите внимание, функция принимает два аргумента, т.к. формируется двумерная матрица размерами 2x2. То есть, число аргументов функции равно размерности матрицы и каждый аргумент соответствует индексу по своей оси. При выполнении этой программы в консоли увидим результат:

```python
[[  0.   1.]  
 [100. 101.]]
```

Отсюда хорошо видно как менялись значения x, y при формировании матрицы. При формировании первой строки x = 0, а y менялся от 0 до 1, при формировании второй строки: x = 1, y от 0 до 1.

Часто совместно с fromfunction используют лямбда-функции в виде:

```python
np.fromfunction(lambda x, y: x*100+y, (2, 2))
```

Результат будет тем же.

Следующая функция fromiter позволяет формировать массив на основе любого итерируемого объекта. Например:

```python
np.fromiter("hello", dtype='U1')
```

Здесь строка воспринимается как итерируемый объект и разбивается по символам. Или, можносделатьтак:

```python
def getRange(N):
    for i in range(N):
        yield i
```
 
```python
a = np.fromiter(getRange(4), dtype='int8')
print(a)
```

Здесь в качестве объекта передается функция-генератор и на выходе получаем одномерный массив чисел:

```python
[0 1 2 3]
```

Последняя функция, которую мы рассмотрим fromstring позволяет создавать массив из строковых данных, например, так:

```python
np.fromstring('1 2 3', dtype='int16', sep= ' ')
```
Здесь параметр sep определяет разделитель между данными. Если числа следуют через запятую, то это явно нужно указать в разделителе:

```python
np.fromstring('1, 2, 3', dtype='int16', sep= ',')
```

# Свойства и представления массивов, создание их копий

```python
a = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
```

```python
a.dtype
```
возвратит текущий тип данных элементов массива:
```python
dtype('float64')
```
Но через него мы также можем поменять тип данных, если присвоить ему другое определение:
```python
a.dtype = np.int8()
```
Мы здесь используем класс int8 для описания целочисленного типа в 8 бит (1 байт). Все данные будут преобразованы и при выводе массива увидим значения:

```python
array([-102, -103, -103, -103, -103, -103,  -71,   63, -102, -103, -103,  
       -103, -103, -103,  -55,   63,   51,   51,   51,   51,   51,   51,  
        -45,   63, -102, -103, -103, -103, -103, -103,  -39,   63,    0,  
          0,    0,    0,    0,    0,  -32,   63,   51,   51,   51,   51,  
         51,   51,  -29,   63,  102,  102,  102,  102,  102,  102,  -26,  
         63, -102, -103, -103, -103, -103, -103,  -23,   63,  -51,  -52,  
        -52,  -52,  -52,  -52,  -20,   63 ], dtype=int8)
```
Их стало больше. Изначально имели длину массива в 9 элементов, теперь стало:

```python
a.size  # 72 элемента
```

Свойство size возвращает число элементов массива вне зависимости от его размерности. Почему массив стал иметь 72 элемента вместо 9? Ну, во-первых, можно заметить, что на каждый исходный элемента приходится 72:9 = 8 чисел типа int8 (1 байт). То есть, изначальный тип float64 был разложен на 8 байт. Что вполне логично, так как 64 бит = 8 байт. И, фактически, все исходные вещественные данные были просто представлены набором байт. Отсюда такое превращение одного массива в другой. При этом потерь данных не произошло и, если мы снова вернем тип float64:

```python
a.dtype = np.float64()
```
то увидим исходный массив:

```python
array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
```

По этой же причине, если менять тип в уже существующем массиве, скажем, на float32:

```python
a.dtype = 'float32'
```

то число его элементов увеличится вдвое:

```python
a.size # 18 элементов
```

а содержимое станет следующим:
```python
array([-1.58818684e-23,  1.44999993e+00, -1.58818684e-23,  1.57499993e+00,  
        4.17232506e-08,  1.64999998e+00, -1.58818684e-23,  1.69999993e+00,  
        0.00000000e+00,  1.75000000e+00,  4.17232506e-08,  1.77499998e+00,  
        2.72008302e+23,  1.79999995e+00, -1.58818684e-23,  1.82499993e+00,  
       -1.07374184e+08,  1.84999990e+00], dtype=float32)
```

Вот так ведут себя массивы NumPy при изменении их типов данных.

Далее, если требуется узнать сколько байт занимает один элемент, то можно воспользоваться свойством:
```python
a.itemsize # вернет 4 (байта)
```
Соответственно, размер памяти для всего массива можно вычислить так:
```python
a.size*a.itemsize # вернет 72 (байта)
```

## Представления массивов (ndim, shape, reshape)

Давайте теперь создадим массив размерностью 3x4x5:
```python
b = np.ones( (3, 4, 5) )
```
Узнать количество его осей, можно через свойство ndim (доступно только для чтения):
```python
b.ndim # вернет значение 3
```

Чтобы определить размеры каждой из осей, используется свойство shape:
```python
b.shape # вернет кортеж (3, 4, 5)
```

С его помощью мы можем менять размерность массива, главное, чтобы общее число элементов оставалось прежним. Например, сделать так:
```python
b.shape = 60 # все 60 элементов вытянутся в строку
b.shape = (12, 5) # массив размерностью 12x5
```

***Обратите внимание, не создаются новые массивы, а лишь меняется представление текущего. 

![[Pasted image 20230508223309.png]]


```python
c = b.reshape(3, 2, 10)
```

reshape возвращает массив с новой указанной размерностью (прежний массив остается без изменений).

![[Pasted image 20230508223322.png]]

Мы легко можем в этом убедиться. Изменим элемент в массиве b:

```python
b[0, 0] = 10
```

и это скажется на первом значении массива c. Хотя id этих ссылок будут разными:

```python
print( id(b), id(c) )  # разные значения
```

Это связано с тем, что они ссылаются на разные представления одного и того же массива, а не на его данные. То есть, пример функции reshape() показывает, что в пакете NumPy разделяются понятия данные и представление этих данных. 

Также при работе с NumPy следует помнить, что представления могут формироваться разными способами. Метод reshape() – это лишь один частный пример. Если выполнить транспонирование матрицы b и использовать для этого свойство T:

```python
d = b.T  # T – транспонирование матрицы (12, 5)
```

то получим еще одно представление, на которое будет ссылаться переменная d, размерностью:

```python
d.shape # возвратит кортеж (5, 12)
```

При этом, сама матрица b останется неизменной.

***Главное понимать, что в NumPy массивы и их представления – это разные понятия.***

## Метод view() для создания представления

У каждого массива array существует метод view(), который возвращает копию его представления. Предположим, мы присваиваем один массив другому:

```python
a = np.array([1,2,3,4,5,6,7,8,9])
b = a
```

Копирования здесь никакого происходить не будет. Следовательно, если дальше по программе изменить форму массива через одну из этих ссылок, например, так:

```python
a.shape = 3,3
```

то вторая ссылка b также будет ссылаться на это измененное представление. 

Чтобы разрешить эту проблему достаточно создать новое представление начального массива a с помощью метода view():

```python
a = np.array([1,2,3,4,5,6,7,8,9])
b = a.view()  # создание нового представления
```

## Создание копий массивов(copy)

Иногда в программе все же нужно создавать копии массивов. Это можно сделать несколькими способами. В последних версиях NumPy функция array() возвращает копию переданного ей массива, например:

```python
a = np.array([1,2,3,4,5,6,7,8,9])
b = np.array( a )  # создается копия массива
```

Или же, копию можно получить с помощью метода copy объекта array:

```python
c = a.copy()  # создание копии массива
```

При этом происходит копирование всех свойств объекта array. Последний вариант предпочтителен, когда нам нужно получить полную копию массива, а не просто новый объект array.

#  Изменение формы массивов, добавление и удаление осей

## Изменение размерности массивов (shape, reshape, ravel, resize)

```python
a = np.arange(10)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Мы уже знаем, что для изменения формы этого массива, достаточно указать свойству shape кортеж с новыми размерами, например, так:

```python
a.shape = 2, 5   # массив размерностью 2x5
```

В результате изменится представление массива, на которое ссылается переменная a. Если же требуется создать новое представление массива, сохранив прежнее, то следует воспользоваться методом reshape():

```python
b = a.reshape(10)  # массив [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Ссылки b и a будут использовать одни и те же данные, то есть, изменение массива через b:

```python
b[0] = -1
```

приведет к изменению соответствующего элемента массива a:
```python
array([[-1,  1,  2,  3,  4],  
       [ 5,  6,  7,  8,  9]])
```

Также следует помнить, что у свойства shape и метода reshape() размерность должна охватывать все элементы массива. Например, вот такая команда:
```python
a.shape = 3, 3
```
приведет к ошибке, т.к. размерность 3x3 = 9 элементов, а в массиве 10 элементов. Здесь всегда должно выполняться равенство:
```
n1 x n2 x … x nN = число элементов массива
```
Но допускается делать так:
```python
a.shape = -1, 2  # размерность 5x2
```
Отрицательное значение -1 означает автоматическое вычисление размерности по первой оси. По второй берется значение 2. В этом случае получим размерность 5x2.

То же самое можно делать и в методе reshape():
```python
b.reshape(-1, 1) # размерность 10x1
b.reshape(1, -1) # размерность 1x10
```
Обратите внимание, в последних двух случаях мы получаем представления двумерных массивов, преобразуя одномерный. Это важный момент, так как на выходе метода reshape() получается матрица с двумя осями (строки и столбцы), тогда как изначально массив b имел только одну ось. Не случайно последнее представление отображается с двумя квадратными скобками:
```python
array([[-1,  1,  2,  3,  4,  5,  6,  7,  8,  9]])
```
Первая скобка – это первая ось (строка), а вторая скобка (вторая ось) описывает столбцы. Одномерный же массив b отображается с одной квадратной скобкой:
```python
array([-1,  1,  2,  3,  4,  5,  6,  7,  8,  9])
```
Используя отрицательный индекс, можно делать и такие преобразования:
```python
b.reshape(2, -1)  # размерность 2x5
b.reshape(-1, 2)  # размерность 5x2
```

Первое представление (2x5) отображается следующим образом:
```python
array([[-1,  1,  2,  3,  4],  
       [ 5,  6,  7,  8,  9]])
```

Здесь снова мы видим две квадратные скобки (значит, массив двумерный). Первая описывает ось axis0, отвечающую за строки, а вложенные скобки описывают вторую ось axis1, отвечающую за столбцы.

Если нам требуется многомерный массив преобразовать в обычный одномерный, то можно воспользоваться методом ravel(), который возвращает новое представление, не меняя текущего:
```python
c = b.ravel() # с ссылается на одномерное представление массива
```
Если же нам нужно текущий массив преобразовать в одномерный, то это можно сделать так:
```python
b.shape = -1
```
Помимо свойства shape можно использовать метод resize, который выполняет подобную операцию с текущим массивом. Например:
```python
a.resize(2, 5) # массив 2x5
```
Но, как мы уже говорили, вот такая строчка приведет к ошибке:
```python
a.resize(3, 3)  # ошибка: 3x3 != 10
```

Однако, мы все-таки можем выполнить такую операцию, указав дополнительно флаг refcheck=False:
```python
a.resize(3, 3, refcheck=False)  # массив 3x3
```
или так:
```python
a.resize(4, 5, refcheck=False) # массив 4x5
```
В первом случае происходит удаление одного 10-го элемента, а во втором случае – добавление 4∙5 - 3∙3 = 11 нулей. Это очень удобно, когда нам нужно менять не только форму, но и размер самого массива.

## Транспонирование матриц и векторов (.T)


```python
a = np.array([(1, 2, 3), (1, 4, 9), (1, 8, 27)])
```

то операция транспонирования может быть реализована так:
```python
b = a.T
```

Обратите внимание, мы здесь создаем лишь новое представление тех же самых данных массива a. И изменение элементов в массиве b:
```python
b[0, 1] = 10
```

приведет к соответствующему изменению значения элемента и массива a. Это следует помнить, используя операцию транспонирования.

Транспонирование векторов работает несколько иначе. Предположим, имеется одномерный массив:
```python
x = np.arange(1, 10)
```
и мы выполняем операцию транспонирования:
```python
x.T
```

В результате ничего не изменилось: вектор как был строкой, так строкой и остался. Почему? Дело в том, что массив x имеет только одну размерность, поэтому здесь нет понятия строк и столбцов. Соответственно, операция транспонирования ни к чему не приводит. Чтобы получить ожидаемый эффект, нужно добавить к массиву еще одну ось, например, так:
```python
x.shape = 1, -1
```
И теперь, при транспонировании получим вектор-столбец:
```python
x.T # вектор-столбец 9x1
```
## Добавление и удаление осей (expand_dims, squeeze,)

```python
-   np.expand_dims(a, axis) – добавление новой оси;
-   np.squeeze(a[, axis]) – удаление оси (без удаления элементов).
```

Давайте предположим, что у нас имеется некий многомерный массив:
```python
x_test = np.arange(32).reshape(8, 2, 2) # массив 8x2x2
```
И нам потребовалось добавить еще одно измерение (ось), причем, в самое начало, то есть, ось axis0. Сейчас на этой оси 8 элементов – матриц 2x2, но мы хотим сделать четырехмерный массив, сохранив остальные три оси и их данные без изменений. Как раз это достаточно просто сделать с помощью функции expand_dims, следующим образом:
```python
x_test4 = np.expand_dims(x_test, axis=0)
```
Обращаясь к свойству shape:
```python
x_test4.shape # (1, 8, 2, 2)
```

Видим, что массив стал четырехмерным и первая добавленная ось axis0 содержит один элемент – трехмерный массив 8 x 2 x 2. При необходимости, мы всегда можем добавить новый элемент на эту ось:
```python
a = np.append(x_test4, x_test4, axis=0) # размерность (2, 8, 2, 2)
```
или удалить ненужные элементы:
```python
b = np.delete(a, 0, axis=0) # размерность (1, 8, 2, 2)
```
Здесь второй параметр 0 – индекс удаляемого элемента на оси axis0.

Если нам нужно добавить последнюю ось в массиве, то для этого можно записать такую команду:
```python
b = np.expand_dims(x_test4, axis=-1) # размерность (1, 8, 2, 2, 1)
```
Отрицательный индекс -1 – это следующая с конца ось. Если указать индекс -2, то добавится предпоследняя ось и так далее. Отрицательные индексы очень удобно использовать при работе с массивами произвольных размерностей.

Следующая функция squeeze позволяет удалить все оси с одним элементом. Например, строчка:
```python
c = np.squeeze(b) # размерность (8, 2, 2)
```
превращает массив размерностью (1, 8, 2, 2) в массив размерностью (8, 2, 2). При необходимости, дополнительно мы можем самостоятельно указать оси, которые следует удалять, например, так:
```python
c = np.squeeze(b, axis=0) # удалит только ось axis0, не затронув другие
```
Но, если указать ось с числом элементов больше 1, то возникнет ошибка:
```python
c = np.squeeze(b, axis=1) # ошибка, на оси axis1 8 элементов
```
## Объект newaxis

В NumPy добавлять новые оси иногда удобнее с помощью специального объекта np.newaxis. Например, пусть у нас есть одномерный массив:
```python
a = np.arange(1, 10) # array([1, 2, 3, 4, 5, 6, 7, 8, 9])
```
У него одна ось – одно измерение. Добавим еще одну ось, допустим, в начало. С помощью объекта np.newaxis это можно сделать так:
```python
b = a[np.newaxis, :] # добавление оси axis0
b.shape # (1, 9)
```
Или, можно прописать сразу две оси:
```python
c = a[np.newaxis, :, np.newaxis]
c.shape # (1, 9, 1)
```

# Объединение и разделение массивов

## Функции hstack и vstack

Предположим у нас есть два двумерных массива:
```python
a = np.array([(1, 2), (3, 4)])
b = np.array([(5, 6), (7, 8)])
```

![[Pasted image 20230510173003.png]]

Их можно объединить как по горизонтали, так и по вертикали, с помощью функций:
```python
np.hstack([a, b])  # объединение по оси axis1 (размерность 2x4)
np.vstack([a, b])  # объединение по оси axis0 (размерность 4x2)
```
Примеры работы этих двух функций представлены на рисунке ниже:

![[Pasted image 20230510173010.png]]

Эти же операции можно выполнять и с многомерными массивами. Например, определим два трехмерных массива:
```python
a = np.fromiter(range(18), dtype='int32')
b = np.fromiter(range(18, 36), dtype='int32')
a.resize(3, 3, 2)
b.resize(3, 3, 2)
```

И выполним функции:
```python
c = np.hstack([a, b])  # размерность 3x6x2
d = np.vstack([a, b])  # размерность 6x3x2
```
Как видите, здесь произошло формальное объединение по оси axis1 в функции hstack и по оси axis0 в функции vstack.

Разумеется, чтобы эти функции работали, размерность массивов по объединяемым осям должны совпадать.

Аналогичным образом происходит объединение и одномерных массивов:
```python
a = np.fromstring('1 2 3 4', sep = ' ')
b = np.fromstring('5 6 7 8', sep = ' ')
```

И при выполнении:
```python
np.hstack([a, b])
```
получим:
```python
array([1., 2., 3., 4., 5., 6., 7., 8.])
```

А во втором случае:
```python
np.vstack([a, b])
```
результатом будет двумерный массив:
```python
array([[1., 2., 3., 4.],

       [5., 6., 7., 8.]])
```

## Функции column_stack и row_stack

 Чтобы результат выглядел вот так:

![[Pasted image 20230510173018.png]]

Для этого хорошо подходит функция column_stack():
```python
np.column_stack([a, b]) # формирование массива 4x2
```

Если с ее помощью объединять двумерные и многомерные массивы, то она будет давать тот же результат, что и функция hstack().

Другая аналогичная функция row_stack(), в принципе, делает то же самое, что и функция vstack() заметных отличий здесь нет. Ее можно использовать так:
```python
np.row_stack([a, b]) # матрица 2x4
```
## Функция concatenate

Для объединения массивов вдоль строго определенной оси можно воспользоваться функцией concatenate(). Например, возьмем два трехмерных массива:
```python
a = np.arange(1, 13)
b = np.arange(13, 26)
a.resize(3, 3, 2)
b.resize(3, 3, 2)
```
И объединим их по каждой из осей:
```python
c0 = np.concatenate([a, b], axis=0) # размерность 6x3x2
c1 = np.concatenate([a, b], axis=1) # размерность 3x6x2
c2 = np.concatenate([a, b], axis=2) # размерность 3x3x4
```
## Объекты r и c

Еще один способ объединения и создания массивов – это использование специальных объектов r_ и c_. Например, объект r_ создает копии массивов, следующими способами:
```python
np.r_[ [1, 2, 3], 4, 5]  # список + дополнительные элементы
np.r_[ 1:9, 90, 100] # срез + два элемента
np.r_[ np.array([1,2,3]), np.array([4,5,6])] # объединение двух массивов
np.r_[ [(1,2,3), (4,5,6)], [(7,8,9)] ]  # объединение двумерного и одномерного списков
```

По аналогии работает и второй объект c_, только объединение выполняется по второй оси axis1:
```python
np.c_[1:5]
np.c_[ [1, 2, 3], [4, 5, 6]]
np.c_[ [(1,2,3), (4,5,6)], [[7],[8]] ]
```
## Разделение массивов (hsplit, vsplit, array_split)

Массивы в NumPy можно не только объединять, но и разделять. Для этого существуют специальные функции hsplit и vsplit. Рассмотрим их работу на простых примерах. Пусть имеется одномерный массив из 10 элементов:
```python
a = np.arange(10)
```
И мы хотим разделить его на две равные части. Это реализуется с помощью функции hsplit:

```python
np.hsplit(a, 2)
```

которая возвращает список из двух массивов. Второй параметр 2 указывает число частей, на которые делится исходный массив. Причем, деление выполняется по горизонтали. Если в нашем примере указать 3 части, то возникнет ошибка:
```python
np.hsplit(a, 3) # ошибка 10 на 3 нацело не делится
```
так как 10 элементов нельзя равномерно разбить на 3 части.

Также ошибка будет и при разбиении этого массива по вертикали:
```python
np.vsplit(a, 2) # ошибка: нет вертикальной оси
```
так как массив имеет одну горизонтальную ось. Чтобы вторая функция сработала, преобразуем массив a в вектор столбец:
```python
a.shape = 10, -1 # вектор-столбец
```
а, затем, разобьем по вертикали:
```python
np.vsplit(a, 2)
```
На выходе получим два одномерных массива длиной 5 элементов.

Эти же функции можно использовать и с многомерными массивами, например, так:
```python
a = np.arange(12)
a.resize(2, 6) # двумерный массив 2x6
```
```python
np.hsplit(a, 2) # разбиение по горизонтали
np.vsplit(a, 2) # разбиение по вертикали
```

**Функция array_split**

Рассмотренные функции выполняют разбиение или по первой оси axis0 или по второй оси axis1. Но что если нам нужно выполнить разбиение по произвольной оси многомерного массива? Для этого существует функция array_split(). Ее работа аналогична рассмотренным выше функциям, только дополнительно указывается ось разбиения. Например:

```python
a = np.arange(18)
a.resize(3, 3, 2)
 
np.array_split(a, 2, axis=2)
np.array_split(a, 3, axis=0)
np.array_split(a, 3, axis=1)
```


# Индексация, срезы, итерирование массивов

## Индексация и срезы многомерных массивов

В базовом варианте индексация и срезы многомерных массивов работают также как и в одномерных, только индексы указываются для каждой оси. Например, объявим двумерный массив:

```python
x = np.array([(1, 2, 3), (10, 20, 30), (100, 200, 300)])
```

![[Pasted image 20230512172547.png]]

```python
x[0, :] # array([1, 2, 3])
```

То есть, не указывая какие-либо индексы, NumPy автоматически подставляет вместо них полные срезы.

Для извлечения столбцов мы уже должны явно указать полный срез в качестве первого индекса:

```python
x[:,1] # array([  2,  20, 200])
```

Итерирование двумерных массивов можно выполнять с помощью вложенных циклов, например:

```python
for row in x:
    for val in row:
        print(val, end=' ')
    print()
```

Если же необходимо просто перебрать все элементы многомерного массива, то можно использовать свойство flat:

```python
for val in x.flat:
    print(val, end=' ')
```

У массивов более высокой размерности картина индексации, в целом выглядит похожим образом. Например, создадим четырехмерный массив:

```python
a = np.arange(1, 82).reshape(3, 3, 3, 3)
```

Тогда для обращения к конкретному элементу следует указывать четыре индекса:

```python
a[1, 2, 0, 1] # число 47
```

Для выделения многомерного среза, можно использовать такую запись:

```python
a[:, 1, :, :] # матрица 3x3x3
```

Если же нужно задать два последних индекса, то полные срезы у первых двух осей указывать обязательно:

```python
a[:, :, 1, 1] # матрица 3x3
a[0:2, 0:2, 1, 1] # матрица 2x2
```
Пакет NumPy позволяет множество полных подряд идущих срезов заменять троеточиями. Например, вместо a[:, :, 1, 1] можно использовать запись:

```python
a[..., 1, 1] # эквивалент a[:, :, 1, 1]
```

## Списочная индексация

Помимо указания у массивов обычных индексов или срезов в NumPy существует еще один способ индексирования – через списки или массивы целых чисел.

```python
a = np.arange(1, 9) # array([1, 2, 3, 4, 5, 6, 7, 8])
```

Далее, смотрите, если указать обычный числовой индекс, то получим одно значение соответствующего элемента:

```python
a[0] # значение 1
```

Но, если вместо числового индекса указать список:

```python
b = a[[0]] # array([1])
```
то на выходе уже получим копию массива из одного первого значения исходного. То есть, выполняя далее операцию:

```python
b[0] = 100
```

Изменение массива b не приведет к изменению данных в массиве a.

А что будет, если в списке указать несколько индексов? Например, так:

```python
a[[0, 1, 7, 5]] # array([1, 2, 8, 6])
```

На выходе получаем новый массив, состоящий из соответствующих значений. Или, можно сделать даже так:

```python
a[[0, 0, 1, 1, 1, 2, 3, 4, 5, 6, 7]] # array([1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8])
```

То есть, мы здесь имеем, фактически, способ формирования новых массивов на основе других массивов. В списке достаточно перечислить индексы нужных элементов и на выходе формируется массив с соответствующими значениями.

Кроме обычных списков языка Python мы можем передавать и массивы NumPy, состоящие из целых значений. Например, так:

```python
indx = np.array([0, 0, 1, 1, 1, 2])
a[indx] # array([1, 1, 2, 2, 2, 3])
```

Или, с булевыми значениями:

```python
bIndx = [True, True, False, False, False, True, False, False]
a[bIndx] # array([1, 2, 6])
```

В результате останутся только те элементы, которым соответствуют индексы True. Причем, длина списка (или массива) bIndx должна совпадать с длиной массива a, иначе произойдет ошибка.

Последний вариант списочной индексации используется очень часто. Например, мы можем сформировать массив индексов путем какой-либо булевой операции над массивом:
```python
i = a > 5 # array([False, False, False, False, False,  True,  True,  True])
```

А, затем, использовать его, чтобы оставить только нужные элементы:

```python
a[i] # array([6, 7, 8])
```

Или, все это можно записать короче в одну строчку:

```python
a[a > 5] # array([6, 7, 8])
```


## Списочная индексация и многомерные массивы

Фактически, массив индексов определяет значения и форму создаваемого массива. Например, если взять тот же одномерный массив:

```python
a = np.arange(1, 9)
```

но набор индексов определить как двумерный массив:

```python
i = np.array([[0, 1], [2, 3]])
```

то на выходе будет формироваться уже двумерный массив:

```python
a[i] # array([[1, 2], [3, 4]])
```

Только в этом случае индексы i должны определяться именно массивом NumPy, а не списком Python.

Так можно создавать массивы любых размерностей. Возьмем двумерный массив:

```python
a = np.arange(1, 13).reshape(3, 4)
```

и одномерный список индексов:

```python
indx = [2, 1, 0]
a[indx]
```

На выходе получим массив:

```python
array([[ 9, 10, 11, 12],  
      [ 5,  6,  7,  8],  
       [ 1,  2, 3,  4]])
```

Здесь индексы обозначают номера строк двумерного массива. В результате, строки нового массива идут в обратном порядке. Далее, пропишем индексы в виде двумерного массива:

```python
indx = np.array([[1, 0], [2, 1]])
a[indx]
```

Результатом будет трехмерный массив:

```python
array([[[ 5,  6,  7,  8],  
        [ 1,  2,  3,  4]],  
  
       [[ 9, 10, 11, 12],  
        [ 5,  6,  7,  8]]])
```

Каждый индекс двумерного массива соответствует определенной строке этого массива. А двумерная форма индексов лишь указывает как упаковать строки в новом массиве. То есть, вместо каждого индекса подставляется своя строка и получается трехмерный массив.

Если же мы хотим выбирать из двумерного массива не строки, а отдельные элементы и на их основе формировать новые массивы, то следует использовать два списка. Первый список по прежнему будет указывать строки массива, а второй – индексы столбцов у каждой строки. Например, так:

```python
i0 = [0, 1]
i1 = [1, 2]
a[i0, i1] # array([2, 7])
```

Работу такого списочного индексирования можно представить в виде:

![[Pasted image 20230512172602.png]]

При множественной списочной индексации допускается указывать конкретные индексы и срезы. Например:

```python
a[:, i1]
```

В этом случае получим уже матрицу 3x2, то есть, второй список i1 здесь используется для выделения столбцов целиком, а не одного только элемента. Соответственно, строчка:

```python
a[i0, 1] # array([2, 6])
```

выделим массив из двух значений 2 и 6.

## Изменение массивов через списочную индексацию

С помощью списков можно не только создавать новые массивы, но и менять значения в исходном. Например, возьмем одномерный массив:

```python
a = np.arange(7) # array([0, 1, 2, 3, 4, 5, 6])
```

и изменим его следующие элементы:

```python
a[[0, 4, 6]] = [-1, -2, -3] # array([-1,  1,  2,  3, -2,  5, -3])
```

Если в списке индексов имеются повторы, то новое значение будет соответствовать последнему значению:

```python
a[[0, 0, 0, 1]] = [1, 2, 3, 100] # array([  3, 100,   2,   3,  -2,   5,  -3])
```

Здесь в первый элемент (с индексом 0), в итоге, запишется число 3. 

Или можно выполнить вот такую операцию:

```python
a[[0, 0, 0]] = a[[0, 0, 0]] + 3
```

Здесь сначала будет выполнена операция списочного индексирования a[[0, 0, 0]], а уже потом добавлено значение 3. То есть, это запись эквивалентна следующей:

```python
a[0] = a[0] + 3
```

Аналогично все выполняется и при такой команде:

```python
a[[0, 0, 1, 2]] += 1 # array([  7, 101,  3,   3,  -2,   5,  -3])
```

Она эквивалента записи:

```python
a[[0, 1, 2]] += 1 # array([  7, 101,   3,   3,  -2,   5,  -3])
```

Соответственно, элементам с индексами 0, 1 и 2 будет прибавлена 1. Вот этот момент следует иметь в виду при работе с массивами NumPy.

# Базовые математические операции над массивами

Предположим, имеется обычный список и массив, созданный на его основе:

```python
lst = [1, 2, 3]
a = np.array([1, 2, 3])
```

Сейчас вы увидите принципиальную разницу между двумя этими объектами. Умножим их на число 2:

```python
lst*2 # список: [1, 2, 3, 1, 2, 3]
a*2 # массив: array([2, 4, 6])
```

Видите, при умножении списка языка Python, он дублируется дважды, а при умножении на NumPy массив – каждый его элемент умножается математически на число 2. Если бы мы захотели то же самое реализовать непосредственно на Python, оперируя списками, то пришлось бы делать что-то вроде:

```python
[x*2 for x in lst]
```

Но выполнялась бы такая конструкция дольше, чем в случае с массивом NumPy. Именно благодаря удобству и скорости библиотека NumPy и приобрела свою популярность.

Итак, с массивами NumPy мы можем выполнять все базовые математические операции:

![[Pasted image 20230512173106.png]]

Пусть у нас задан тот же одномерный массив:

```python
a = np.array([1, 2, 3])
```

Все указанные в таблице операции выполняются следующим образом:

```python
-a # унарный минус
a + 2 # сложение с числом
2 + a  # так тоже можно записывать
a - 3 # вычитание с числом
a * 5 # умножение на число
a / 5  # деление на число
a // 2  # целочисленное деление
a ** 3  # возведение в степень 3
a % 2  # вычисление по модулю 2
```

Разумеется, приоритеты этих операций такие же, что и при обычных математических вычислениях. А на выходе мы получаем новый массив с соответствующими значениями.

Давайте теперь добавим еще один массив:

```python
b = np.array([3, 4, 5])
```

и посмотрим на эти же операции, но с участием двух массивов:

```python
a - b  # array([-2, -2, -2])
b + a  # array([4, 6, 8])
a * b  # array([ 3,  8, 15])
b / a  # array([3. , 2. , 1.66666667])
b // a # array([3, 2, 1], dtype=int32)
b ** a # array([  3,  16, 125], dtype=int32)
b % a  # array([0, 0, 2], dtype=int32)
```

Везде мы видим поэлементные операции. Соответственно, чтобы они выполнялись, массивы должны быть согласованы по длине. Например, если взять массив:

```python
b = np.array([3, 4, 5, 6])
```
и выполнить операцию:

```python
a + b  # ошибка: длины массивов не совпадают
```

то возникнет ошибка из-за несовпадения длин массивов. Но вот такая операция с двумерным массивом b сработает:

```python
b = np.arange(1, 7)
b.resize(2, 3)
a + b
```

В этом случае массив a будет применен к каждой строке массива b и на выходе увидим результат:

![[Pasted image 20230512173134.png]]

Такое поведение получило название **транслирование массивов**. Подробнее о нем мы еще будем говорить.

Все рассмотренные операции можно распространить и на многомерные массивы, главное, чтобы они были согласованы по размерам. Я приведу два небольших примера, так как думаю, общий принцип здесь понятен. Пусть у нас трехмерный и двумерный массивы:

```python
a = np.arange(1, 19)
a.resize(3, 3, 2)
b = np.ones((3, 2))
```
С ними можно выполнять такие очевидные операции:

```python
a - b
a * 10
a // b
```

И так далее. Причем, двумерный массив b может быть применен к трехмерному массиву a благодаря операции транслирования, так как их размеры согласованы. На самом деле, умножение трехмерного массива на число также реализуется через транслирование числа по всем элементам массива a.

То есть, если нам нужно произвести какие-либо математические операции с массивом и изменения сохранить в нем же, то удобно использовать такие сокращенные записи. Выполняются они очевидным образом, например, так:

```python
a = np.array([1, 2, 6, 8])
a += 5
b = np.ones(4)
b *= a
```

И так далее. Но есть один нюанс работы этих операторов. Если, например, массив b определить с типом данных float64:

```python
b = np.ones(4, dtype='float64')
```

а массив a имеет тип int32 (можно посмотреть через свойство a.dtype), то операция:

```python
a += b
```

приведет к ошибке. 

***Вообще, следует помнить правило:***
При выполнении арифметических операций тип данных автоматически приводится к более общему.

То есть, при работе с целочисленными и вещественными числами на выходе получаем вещественные. При работе с вещественными и комплексными – комплексные. И так далее. Всегда результатом имеем более общий тип данных.

Все описанные математические операции можно комбинировать и записывать в виде:

```python
(a + b)*5 - 10
```

# Булевы операции и функции, значения inf и nan

Предположим, имеется одномерный массив:

```python
a = np.array([1, 2, 3, 10, 20, 30])
```
и мы хотим определить все числа, которые больше 5. 

```python
indx = a > 5
a[indx]
```

На выходе получим массив из трех элементов, которым соответствуют позиции True:

```python
array([10, 20, 30])
```

Видите, как это может быть удобно: выделить нужные элементы, не используя ни одного оператора цикла языка Python. А, значит, такая конструкция будет работать достаточно быстро (так как внутри реализована на языках Си и Fortran).

Конечно, эту запись можно еще упростить и записать в виде:
```python
a[ a > 5 ]
```

Результат будет тем же. По аналогии работают и другие булевы операторы:

![[Pasted image 20230512173426.png]]

Здесь в качестве операндов a и b могут выступать как числа, так и массивы NumPy. Например, добавим еще один массив:

```python
b = np.array([1, 2, 3, 4, 5, 6])
```

Тогда можно использовать сравнения:

```python
a == b    # array([ True,  True,  True, False, False, False])
a >= b    # array([ True,  True,  True,  True,  True,  True])
a <= b    # array([ True,  True,  True, False, False, False])
a != b    # array([False, False, False,  True,  True,  True])
```

## Функции greater, less, equal

Вместо записи операторов в NumPy имеются функции сравнения: greater(), less() и equal(). Их названия говорят сами за себя:

-   greater(a, b) – выполняет сравнение a > b;
-   less(a, b) – выполняет сравнение a < b;
-   equal(a, b) – выполняет сравнение a == b.

Использование их вполне очевидно, например:

```python
np.greater(a, b) # array([False, False,  True, False])
np.less(a, b) # array([ True,  True, False, False])
np.equal(a, b) # array([False, False, False,  True])
```
Но, чаще всего на практике вместо них записывают булевы операторы: >, <, == .

## Функции array_equal, all и any

Но использовать результат сравнения в условных операторах нельзя. Следующая строчка приведет к ошибке:

```python
if(a == b): 
	print("a == b")
```

Для такого сравнения массивов необходимо получать только одно значение True или False, а не объект array. Для этого в пакете NumPy существуют специальная функция np.array_equal(), которую можно применить так:

```python
if np.array_equal(a ,b): 
     print("a == b")
```

Это условие сработает, если оба массива a и b содержат одинаковые значения элементов и равны по длине.

Если нам нужно определить, что хотя бы один элемент массива удовлетворяет указанному условию, то можно воспользоваться функцией any(), например:
для массива 
```python
# a = array([ 1,  2,  3, 10, 20, 30])
np.any(a > 5)    # True 
np.any(a == 5)    # False
np.any(a == b)    # True
```

Если же нужно узнать, все ли элемента массива удовлетворяют условию, то используется функция all():

```python
np.all(a > 5)       # False
np.all(a > 0)       # True
np.all(a == b)     # False
```
## Значения -inf, inf и nan

Пакет NumPy реализован максимально дружественным способом и там, где можно избежать ошибок и продолжить вычисления, он это делает. Например, давайте разделим все значения массива *a* на 0. Из математики мы знаем, что на 0 делить нельзя, но, тем не менее, критической ошибки не возникнет, а все элементы примут значение inf:

```python
a/0
```

с результатом:

```python
input:1: RuntimeWarning: divide by zero encountered in true_divide

array([[inf, inf],  
       [inf, inf],  
       [inf, inf]])
```

Здесь NumPy нас лишь предупредил, что встретилось деление на ноль, но расчеты были завершены и все элементы равны inf.

Это сокращение от английского слова infinity – бесконечность. Действительно, при делении на 0 получаем бесконечность. Именно это и указано в значениях элементов массива. Благодаря использованию этого специального значения, NumPy избежал ошибки деления на 0. Причем, inf – это полноценный элемент массивов. Его можно непосредственно задать при определении:

```python
b = np.array([1, 2, np.inf])
```

И, далее, он может участвовать в вычислениях. Например, умножим b на ноль и посмотрим, что получится:

```python
b*0 # array([ 0.,  0., nan])
```

Последний элемент превратился в nan. Это еще одно сокращение от английского:

not a number (не число)

То есть, значение nan указывает, что в результате арифметической операции третий элемент перестал быть каким-либо числовым значением. Причем, это определение оказывается «прилипчивым». Например, сложим все элементы массива:

```python
c = b*0
```

получим:

```python
c.sum() # nan
```

То есть, любые арифметические операции с nan приводят к nan.

## Функции isnan и isinf

Так как элементы inf и nan не относятся к числам, то для их идентификации, проверки, что текущий элемент массива принимает одно из этих значений, существуют функции isnan() и isinf(). Они возвращают True, если элемент равен nan и inf и Flase – в противном случае. Пусть имеется массив:

```python
b = np.array([1, 2, np.nan, np.inf, -np.inf])
```
к которому применим эти две функции:

```python
np.isinf(b)  # array([False, False, False,  True,  True])
np.isnan(b)  # array([False, False,  True, False, False])
```

На выходе имеем массив с булевыми значениями и True стоит на местах inf (при вызове isinf) и nan (при вызове isnan). Далее, используя этот массив можно исключить нечисловые элементы из массива, например, так:

```python
indx = np.isinf(b)
b[~indx]  # array([ 1.,  2., nan])
```

Здесь исключаются все элементы inf, а операция ~indx инвертирует булевы значения. Аналогично можно отфильтровать значения nan.

## Дополнительные функции: isfinite, iscomplex, isreal

Часто, при работе с массивами требуется определить: являются ли его элементы конечными числами. Для этого используется еще одна функция – isfinit():

```python
# для массива b = np.array([1, 2, np.nan, np.inf, -np.inf])
np.isfinite(b) # array([ True,  True, False, False, False])
```
Соответственно, все не числовые элементы помечены как False, а числовые – как True.

Далее, мы можем уточнять тип числа: комплексное или действительное, с помощью функций iscompex() и isreal(). Например:

```python
a = np.array([1+2j, 3-4j, 5])  # array([1.+2.j, 3.-4.j, 5.+0.j])
np.iscomplex(a) # array([ True,  True, False])
```

Обратите внимание, несмотря на то, что тип данных у всех элементов массива complex128 (посмотреть можно через a.dtype), последний элемент функция iscomplex() пометила как False, так как мнимая часть равна нулю.

Аналогично работает функция isreal():

```python
np.isreal(a) # array([False, False,  True])
```

Только теперь True помечены действительные числа, а False – все остальные. Но, применяя эту функцию к массиву b:

```python
np.isreal(b) # array([ True,  True,  True,  True,  True])
```

получим все значения True. То есть, специальные значения nan и inf отмечаются как действительные.

## Функции logical_and, logical_or, logical_not и logical_xor

В NumPy можно выполнять стандартные булевы операции И, ИЛИ, НЕ, исключающее ИЛИ, применительно к данным массивов. Например, зададим два массива так, чтобы попарно элементы образовывали все возможные комбинации:

```python
X = np.array([True, False, True, False])
Y = np.array([True, True, False, False])
```

И, затем, применим к ним логические операции:

```python
np.logical_and(X, Y) # логическое И: array([ True, False, False, False])
np.logical_or(X, Y) # логическое ИЛИ: array([False,  True, False,  True])
np.logical_not(X) # логическое НЕ: array([False,  True, False,  True])
np.logical_xor(X, Y) # XOR: array([ True,  True,  True,  True])
```

Получили вполне ожидаемые результаты в соответствии с таблицами истинности этих операций.

Все те же операции можно проводить и с числовыми значениями, полагая, что 0 – это False, а любое другое число – True. Например, два таких массива:

```python
a = np.array([1, 0, 2, 0])
b = np.array([3, 4, 0, 0])
```

Будут вести себя идентично массивам X, Y при булевых операциях:

```python
np.logical_and(a, b) # array([ True, False, False, False])
```

# Базовые функции

## Функции sum, mean, min и max

```python
a = np.array([ 1,  2,  3, 10, 20, 30])
```
Вычислим сумму, среднее значение и найдем максимальное и минимальное значения:

```python
a.sum()    # 66
a.mean()  # 11.0
a.max()    # 30
a.min()    # 1
```

Как видите, все достаточно просто. Тот же самый результат будет получен и при использовании многомерных массивов. Например:

```python
a.resize(3, 2)
a.sum()  # 66
```

Но, если требуется вычислить сумму только по какой-то одной оси, то ее можно явно указать дополнительным параметром:

```python
a.sum(axis=0)  # array([24, 42])
a.sum(axis=1) # array([ 3, 13, 50])
```

Точно также работают и остальные три функции, например:

```python
a.max(axis=0)  # array([20, 30])
a.min(axis=1)  # array([ 1,  3, 20])
```

## Базовые математические функции (abs, amax, amin, argmax, argmin, around, mean, log, log2, log10)

Все те же самые операции и многие другие можно выполнять через функции пакета NumPy, а не через методы массива. Вот список основных из них:
![[Pasted image 20230512174151.png]]
Предположим, имеется массив:

```python
a = np.array([-1, 1, 5, -44, 32, 2])
```

тогда для вычисления модулей значений его элементов можно записать команду:

```python
np.abs(a) # array([ 1,  1,  5, 44, 32,  2])
```

На выходе получаем новый массив с абсолютными величинами. То же самое будет, если на вход подать обычный список значений:

```python
np.abs([-1, 1, 5, -44, 32, ])# array([ 1,  1,  5, 44, 32])
```

или просто число:

```python
np.abs(-10.5) # 10.5
```

Эти примеры демонстрируют разные типы входных данных: массив, список, число. Все это допустимо использовать в математических функциях.

Остальные функции работают по аналогии, например:

```python
np.amax(a) # 32
np.log(a) # array([nan, 0. , 1.60943791,  nan, 3.4657359,0.69314718])
np.around(0.7) # 1.0
```

Функции amin, amax, mean, argmax, argmin, при работе с многомерными матрицами, могут делать вычисления по строго определенной оси. Например:

```python
a.resize(2, 3)
np.amax(a, axis=0)  # array([-1, 32,  5])
np.argmax(a, axis=1) # array([2, 1], dtype=int32)
```

И так далее.

## Тригонометрические функции (sin, cos, tan, arccos, arcsin, arctan)

![[Pasted image 20230512174216.png]]
Если это угол, то он представляется в радианах. Например:

```python
a = np.linspace(0, np.pi, 10)
res1 = np.sin(a) # возвращает массив синусов углов
np.sin(np.pi/3)
np.cos([0, 1.57, 3.17])
res2 = np.cos(a) # возвращает массив косинусов углов
np.arcsin(res1) # возвращает арксинусы от значений res1
```

## Функции генерации псевдослучайных чисел (rand, randint, randn, seed)
![[Pasted image 20230512174239.png]]

В самом простом случае, функция rand() позволяет получать случайные числа в диапазоне от 0 до 1:

```python
np.random.rand() # вещественное случайное число от 0 до 1
```

Если требуется получить массив из таких чисел, то можно указать это через первый аргумент:

```python
np.random.rand(5) # array([0.78191696, 0.66581136, 0.46458873, 0.76416839, 0.28206656])
```

Для получения двумерных массивов – два аргумента:

```python
np.random.rand(2, 3) # массив 2x3
```

Если требуется генерировать целые случайные значения, то используется функция randint():

```python
np.random.randint(10) # генерация целых чисел в диапазоне [0; 10)
np.random.randint(5, 10)# генерация в диапазоне [5; 10)
```
Для получения массива из таких случайных чисел дополнительно следует указать параметр size, следующим образом:

```python
np.random.randint(5, size=4) # array([3, 1, 1, 4])
np.random.randint(1, 10, size=(2, 5)) # матрица 2x5
```

Функции rand() и randint() генерируют числа с равномерным законом распределения. Если нужно получать значения с другими широко известными распределениями, то используются функции:

```python
np.random.randn() # нормальная СВ с нулевым средним и единичной дисперсией
np.random.randn(5) # массив из пяти нормальных СВ
np.random.randn(2, 3) # матрица 2x3 из нормальных СВ
np.random.pareto(2.0, size=3) # распределение Паретто с параметром 2,0
np.random.beta(0.1, 0.3, size=(3, 3)) # бета-распределение с параметрами 0,1 и 0,3
```

По умолчанию, все рассмотренные функции при каждом новом запуске генерируют разные числа. Однако, иногда требуются одни и те же их реализации. Например, такой подход часто используется для сохранения начальных случайных значений весов в нейронных сетях. Для этого устанавливают некое начальное значение зерна (seed):

```python
np.random.seed(13) # начальное значение генератора случайных чисел
```

и все последующие запуски будут давать одну и ту же последовательность чисел, например:

```python
np.random.randint(10, size=10) # array([2, 0, 0, 6, 2, 4, 9, 3, 4, 2])
```

Причем, у вас должны получиться такие же числа. Если запустим эту функцию еще раз, то будут получены следующие 10 случайных чисел:

```python
np.random.randint(10, size=10) # array([6, 5, 9, 4, 2, 0, 3, 5, 3, 6])
```

Но, установив зерно снова в значение, например, 13:

```python
np.random.seed(13)
```

числа начнут повторяться:

```python
np.random.randint(10, size=10) # array([2, 0, 0, 6, 2, 4, 9, 3, 4, 2])
np.random.randint(10, size=10) # array([6, 5, 9, 4, 2, 0, 3, 5, 3, 6])
```

## Функции перемешивания элементов массива(shuffle, permutation)

Следующие две функции:

```python
np.random.shuffle() 
np.random.permutation()
```

перемешивают случайным образом элементы массива. 
Например, дан массив:

```python
a = np.arange(10) # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

И нам требуется перетасовать его элементы. В самом простом случае, это делается так:

```python
np.random.shuffle(a) # array([8, 7, 9, 6, 3, 4, 0, 2, 1, 5])
```

Причем, здесь меняется сам массив a. Если вызвать эту функцию еще раз:

```python
np.random.shuffle(a) # array([7, 2, 1, 5, 8, 6, 4, 3, 9, 0])
```

то значения еще раз перетасуются. Но, работает она только с первой осью axis0. Например, если взять двумерный массив:

```python
a = np.arange(1, 10).reshape(3, 3)
```

и вызвать эту функцию:

```python
np.random.shuffle(a)
```

то в массиве aбудут переставлены только строки:

```python
array([[1, 2, 3],  
       [7, 8, 9],  
[4, 5, 6]])
```
Вторая функция возвращает случайную последовательность чисел, генерируя последовательность «на лету»:

```python
np.random.permutation(10) # array([8, 2, 7, 1, 0, 5, 3, 9, 4, 6])
```

## Функции математической статистики (median, var, std, corrcoef, correlate, cov)

Последняя группа общематематических функций, которую мы рассмотрим на этом занятии, отвечает за вычисления статистических характеристик случайных величин. Основные из них, следующие:
![[Pasted image 20230512174319.png]]

Рассмотрим работу этих функций. Предположим, имеются следующие векторы:

```python
x = np.array([1, 4, 3, 7, 10, 8, 14, 21, 20, 23])
y = np.array([4, 1, 6, 9, 13, 11, 16, 19, 15, 22])
```

Эти числа будем воспринимать как реализации случайных величин X и Y. Тогда, для вычисления медианы СВX, можно воспользоваться функцией:

```python
np.median(x) # 9.0
```

Для расчета дисперсии и СКО, функциями:

```python
np.var(x) # дисперсия СВX на основе реализации x
np.std(y) # СКО СВY на основе реализации y
```

Далее, чтобы рассчитать коэффициент корреляции Пирсона, объединим массивы x и y построчно:

```python
XY = np.vstack([x, y]) # матрица 2x10
```

и выполним функцию:

```python
np.corrcoef(XY)
```

Результатом будет матрица 2x2:

```python
array([[1.        , 0.93158099],  
       [0.93158099, 1.        ]])
```

Как ее следует интерпретировать? В действительности, это автоковариационная матрица вектора СВ[X, Y]:

![[Pasted image 20230512174336.png]]

(В этой формуле полагается, что СВX и Y центрированы, то есть имеют нулевое математическое ожидание).

Если нужно вычислить не нормированное МО, то есть, автоковариационную матрицу, то следует воспользоваться функцией:

```python
np.cov(XY) # ковариационная матрица размерностью 2x2
```

Наконец, для вычисления взаимной корреляции между двумя векторамиx и y, используется функция:

```python
np.correlate(x, y) # array([1736])
```

# Произведение матриц и векторов, элементы линейной алгебры

```python
a = np.arange(1, 10).reshape(3, 3)
b = np.arange(10, 19).reshape(3, 3)
a*b
```

В консоли увидим результат:

```python
array([[ 10,  22,  36],  
       [ 52,  70,  90],  
[112, 136, 162]])
```

## Матричное умножение

Но если нам нужно выполнить именно матричное умножение, то есть, строки одной матрицы умножать на столбцы другой и результаты складывать:

![[Pasted image 20230513191103.png]]

то для этого следует использовать специальные функции и операторы. Начнем с функций. Итак, чтобы перемножить две матрицы a и b по всем правилам математики, запишем следующую команду:

```python
np.dot(a, b)
```

Эта функция возвращает новую матрицу (двумерный массив) с результатом умножения:

```python
array([[ 84,  90,  96],  
[201, 216, 231],  
[318, 342, 366]])
```

Тот же результат можно получить и с помощью функции:

```python
np.matmul(a, b)
```

Считается, что этот вариант предпочтительнее использовать при умножении матриц.

## Векторное умножение

Аналогичные операции можно выполнять и с векторами. Математически, если у нас имеются два вектора:

![[Pasted image 20230513191200.png]]

Первое умножение реализуется либо через функцию:

```python
a = np.arange(1, 10)
b = np.ones(9)
np.dot(a, b) # значение 45
```

Либо, более предпочтительной функцией для внутреннего умножения векторов:

```python
np.inner(a, b) # 45
```

Второй вариант умножения (внешнее умножение векторов) реализуется с помощью функции:

```python
np.outer(a, b)
```

получим результат в виде следующей матрицы:

```python
array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],  
       [2., 2., 2., 2., 2., 2., 2., 2., 2.],  
       [3., 3., 3., 3., 3., 3., 3., 3., 3.],  
       [4., 4., 4., 4., 4., 4., 4., 4., 4.],  
       [5., 5., 5., 5., 5., 5., 5., 5., 5.],  
       [6., 6., 6., 6., 6., 6., 6., 6., 6.],  
       [7., 7., 7., 7., 7., 7., 7., 7., 7.],  
       [8., 8., 8., 8., 8., 8., 8., 8., 8.],  
[9., 9., 9., 9., 9., 9., 9., 9., 9.]])
```

Операция умножения матриц и векторов используется довольно часто, поэтому в пакете NumPy имеется весьма полезный перегруженный оператор, заменяющий функцию matmul:

```python
a @ b # значение 45
```

или, с использованием матриц:

```python
a.resize(3, 3)
b.resize(3, 3)
a @ b # аналог np.matmul(a, b)
```
## Умножение вектора на матрицу

Наконец, рассмотрим умножение вектора на матрицу. Это также можно записать двумя способами:

![[Pasted image 20230513191312.png]]

Для реализации первого способа, зададим одномерный вектор и двумерную матрицу:

```python
a = np.array([1,2,3])
b = np.arange(4,10).reshape(3,2) # матрица 3x2
```

И, затем, воспользуемся уже знакомой нам функцией dot:

```python
np.dot(a, b) # array([40, 46])
```

При такой записи, когда одномерный массив записан первым аргументом, а матрица – вторым, получаем умножение вектора-строки на матрицу, то есть, первый способ.

Для реализации второго способа аргументы нужно поменять местами: сначала указать матрицу, а затем, вектор. Но, если мы сейчас это сделаем с нашими массивами, то получим ошибку:

```python
np.dot(b, a) # несогласованность размеров
```

Дело в том, что массив a должен представлять вектор длиной два элемента, так как матрица b имеет размер в 3 строки и 2 столбца:

![[Pasted image 20230513191335.png]]

Определим массивa в два элемента и умножим на матрицу b:

```python
a = np.array([1, 2])
np.dot(b, a) # array([14, 20, 26])
```

Получаем вектор-строку (одномерный массив) как результат умножения. Обратите внимание, по правилам математики вектор aдолжен быть вектором-столбцом, то есть, быть представленным в виде:

```python
a.shape = -1, 1 # вектор-столбец 2x1
```

Но мы использовали вектор-строку. В NumPy так тоже можно делать и это не приведет к ошибке. Результат будет именно умножение матрицы как бы на вектор-столбец. Ну а если использовать вектор-столбец, то и на выходе получим вектор-столбец:

```python
np.dot(b, a) # вектор-столбец 3x1
```

Этого же результат можно достичь, используя оператор @ (перегрузка функции matmul):

```python
a @ b # вектор-столбец 3x1
```

Результат будет тем же. Вот так в NumPy выполняется умножение матриц, векторов и вектора на матрицу.

## Элементы линейной алгебры (функции смотреть в таблице внутри)

Для этого в NumPy существует модуль **linalg**. 

Предположим, имеется квадратная матрица 3x3:

```python
a = np.array([(1, 2, 3), (1, 4, 9), (1, 8, 27)])
```

Первым делом вычислим ранг этой матрицы, чтобы быть уверенным, что она состоит из линейно независимых строк и столбцов:

```python
np.linalg.matrix_rank(a) # рангравен 3
```

Если ранг матрицы совпадает с ее размерностью, значит, она способна описывать систему из трех независимых линейных уравнений. В нашем случае, система уравнений будет иметь вид:

![[Pasted image 20230513191353.png]]

```python
y = np.array([10, 20, 30])
```

Тогда корни уравнения можно вычислить с помощью функции solve:

```python
np.linalg.solve(a, y) # array([-5.  , 10.   , -1.66666667])
```

Другой способ решения этой же системы линейных уравнений возможен через вычисление обратной матрицы. Изначально, уравнение можно записать в векторно-матричном виде:

![[Pasted image 20230513191416.png]]

На уровне пакета NumPy это делается так:

```python
invA = np.linalg.inv(a) # вычисление обратной матрицы
invA @ y # вычисление корней
```

![[Pasted image 20230513191501.png]]

# Множества (unique) и операции над ними

предположим имеется одномерный массив:

```python
a = np.array([1, 2, 3, 4, 4, 3, 2, 1])
```

В нем есть неуникальные (повторяющиеся) значения. Так вот, в множествах все значения должны быть уникальными и представленными в единственном варианте. Чтобы преобразовать массив a в множество используется функция unique:

```python
setA = np.unique(a) # array([1, 2, 3, 4])
```

У функции unique есть несколько полезных параметров. Первый из них return_counts:

```python
np.unique(a, return_counts=True) # (array([1, 2, 3, 4]), array([2, 2, 2, 2]))
```
который позволяет возвращать не только уникальные значения, но и число их вхождений в исходном массиве a.

Следующий параметр return_index позволяет определять индексы первого вхождения уникальных элементов в исходном массиве:

```python
np.unique(a, return_index=True) # (array([1, 2, 3, 4]), array([0, 1, 2, 3]))
```

Наконец, третий параметр return_inverse возвращает индексы, по которым можно точно восстановить исходный массив. 

```python
np.unique(a, return_inverse=True)
```
на выходе получим:

```python
(array([1, 2, 3, 4]), array([0, 1, 2, 3, 3, 2, 1, 0], dtype=int32))
```

Далее, по этой информации можно выполнить восстановление исходного массива a. Делается это так:

```python
setA, indx = np.unique(a, return_inverse=True)
aa = setA[indx] # array([1, 2, 3, 4, 4, 3, 2, 1])
```

Подробнее о таком списочном индексировании мы поговорим на следующем занятии.

Функция unique также может работать и с многомерными массивами. Например:

```python
x = np.array([[0, 1, 1, 2],[0, 1, 1, 2],[9, 1, 1, 2]])
np.unique(x) # array([0, 1, 2, 9])
```

То есть, она просматривает весь массив x и оставляет только уникальные значения. На выходе формируется обычный одномерный массив.

Однако, здесь мы можем дополнительно указывать оси, по которым будет происходить отбор уникальных значений, например, так:

```python
np.unique(x, axis=0)
```

получим результат:

```python
array([[0, 1, 1, 2],  
       [9, 1, 1, 2]])
```

Здесь использовалась первая ось, то есть, определялись уникальные строки. Если указать вторую ось:

```python
np.unique(x, axis=1)
```

то получим уникальные столбцы:

```python
array([[0, 1, 2],  
       [0, 1, 2],  
       [9, 1, 2]])
```

## Операции над множествами

 Первая – это проверка вхождений элементов одного множества в другое. Например, заданы два массива с уникальными значениями (множества):

```python
x = np.array([0, 1, 2, 3])
y = np.array([1, 2, 3, 4, 5, 6, 7, 8])
```

И выполним функцию in1d:

```python
np.in1d(x, y) # array([False,  True,  True,  True])
```

На выходе получим массив булевых значений и там где стоит False означает отсутствие элемента, а там где стоит True – наличие совпадения. Причем, порядок следования элементов не имеет никакого значения. Если перемешать массив y:

```python
np.random.shuffle(y) # array([5, 8, 4, 6, 2, 7, 3, 1])
np.in1d(x, y) # array([False,  True,  True,  True])
```

то видим тот же результат.

### Пересечение множеств

Следующая базовая операция – это пересечение двух множеств, то есть, определение значений, которые входят в оба множества одновременно. Она выполняется с помощью функции:

```python
np.intersect1d(x, y) # array([1, 2, 3])
```
![[Pasted image 20230513191550.png]]

### Объединение множеств

Противоположная ей операция – объединение множеств, реализуется с помощью функции:

```python
np.union1d(x, y) # array([0, 1, 2, 3, 4, 5, 6, 7, 8])
```

Соответственно, получим уникальные числа, которые входят в оба множества:

![[Pasted image 20230513191605.png]]

### Вычитание множеств

Далее, множества можно вычитать друг из друга, причем результат будет зависеть от того, какое множество из какого вычитается:

![[Pasted image 20230513191617.png]]

![[Pasted image 20230513191621.png]]

Реализуются эти операции с помощью функции setdiff1d:

```python
np.setdiff1d(x, y) # array([0])
np.setdiff1d(y, x) # array([4, 5, 6, 7, 8])
```

### Симметричная разность (XOR)

Последняя базовая операция – это вычисление симметричной разности, то есть, остаются не совпадающие значения из двух множеств:

![[Pasted image 20230513191635.png]]

Реализуется это с помощью функции setxor1d:

```python
np.setxor1d(x, y) # array([0, 4, 5, 6, 7, 8])
```

# Транслирование массивов

Представьте, что у нас имеются два массива с разным числом элементов:

```python
a = np.array([1, 2, 3, 10, 20, 30])
b = np.array([2])
```

Можем ли мы выполнять арифметические операции с такими объектами? Оказывается да, можем, например:

```python
a*b # array([ 2,  4,  6, 20, 40, 60])
a+b # array([ 3,  4,  5, 12, 22, 32])
```

В первом случае каждый элемент массива a будет умножен на первый элемент массива b. А во втором случае выполняется аналогичная операция сложения. Но почему это сработало? Например, если мы в массиве b пропишем два элемента:

```python
b = np.array([2, 3])
```

и выполним ту же операцию умножения:

```python
a*b # ошибка, размеры не согласованы
```

возникнет ошибка. Так почему в первом случае это сработало, а во втором – не сработало? Все дело в особенностях работы алгоритма транслирования массивов пакета NumPy, который следует двум правилам:

1.  Если массивы имеют разное число осей (размерностей), то к массиву с меньшим их числом добавляются новые так, чтобы размерности совпадали. (Причем, добавление всегда происходит с оси axis0).
2.  Оси с одним элементом расширяются (по числу элементов) так, чтобы соответствующие размерности двух массивов совпадали.

Чтобы все было понятнее, давайте рассмотрим эти правила на конкретных примерах. Если обратиться к массивам a и b, то число осей у них одинаковое. В этом легко убедиться, выполнив команды:

```python
a.ndim  # 1
b.ndim  # 1
```

То есть, первый пункт выполняется. И, когда массив b содержал всего один элемент, то согласно второму пункту он мог размножиться до размеров массива a. Получаем равные массивы а, значит, с ними можно выполнять любые математические операции.
![[Pasted image 20230513191820.png]]

Соответственно, как только в массив b был добавлен еще один второй элемент, то второй пункт не мог быть реализован, и возникла ошибка при вычислении.

Так выполняется транслирование одномерных массивов. Давайте теперь посмотрим, как работает этот механизм с многомерными массивами. Для начала положим, что имеется двумерный и одномерный массивы:

```python
a = np.arange(1, 10).reshape(3,3)
b = np.array([4, 5, 6])
```

![[Pasted image 20230513191811.png]]

И попробуем их сложить:

```python
a+b # array([[ 5,  7,  9],   [ 8, 10, 12],   [11, 13, 15]])
```

Согласно первому правилу размерность массива b была увеличена до двух, причем, добавлена именно первая ось – axis0:

```
# a: 3 x 3
# b: 1 x 3
```

А, затем, по второму правилу, число элементов вдоль оси axis0  массива b было доведено до трех:

![[Pasted image 20230513191801.png]]

Фактически, так работает механизм транслирования массивов при любых размерностях. 

Пусть имеются два массива:

```python
a = np.arange(6).reshape(3, 1, 2)
b = np.ones(4).reshape(2, 2)
```
Тогда, выполняя операцию:

```python
a * b # массив размерностью (3, 2, 2)
```

Как она была реализована? Смотрите, сначала по первому правилу размерность массива b была доведена до размерности массива a:

```
# a:  3  x 1 x 2
# b: (1) x 2 x 2
```

Затем, по второму правилу все оси с одним элементом были расширены до нужного числа элементов. В итоге, были сформированы два массива размерностями:

```
# a:  3  x (2) x 2
# b: (3) x  2  x 2
```

После их поэлементного умножения, получаем искомый результат. Как видите, все довольно просто.

Однако, если изменить размерность массива a до 2x3x1:

```python
a = a.reshape(2, 3, 1)
```

то при математическом действии с массивом b произойдет ошибка:

```python
a * b # ошибка, размеры не согласованы
```

Смотрите, по первому правилу размерности массивов стали равны:

```
# a:  2  x 3 x 1
# b: (1) x 2 x 2
```

Соответственно вторая ось у массива a содержит 3 элемента, а у массива b – два элемента. Как мы уже знаем, эти размерности не могут быть приведены друг к другу. Отсюда и возникает ошибка при их умножении. Но, если размерность массива b сделать 3x2:

```python
b = np.ones(6).reshape(3, 2)
```

то все заработает:

```python
a * b # массив 2x3x2
```

Вот так происходит транслирование массивов при поэлементных математических операциях.

## Функция ix_()

Благодаря механизму транслирования можно выполнять довольно интересные манипуляции с одномерными массивами. Давайте предположим, что у нас есть три массива с разным числом элементов:

```python
a = np.array([1, 2, 3])
b = np.array([4, 5])
c = np.array([7, 8, 9, 10])
```

И мы собираемся выполнить вот такое вычисление:

```python
a * b + c # ошибка, размеры не согласованы
```

Разумеется, здесь возникнет ошибка, так как число элементов в массивах разное. Но, мы можем привести их к согласованной форме, добавив по две новой оси в каждый из них. Причем, размерности сделаем следующими:

```
# a: 1 x 1 x 3
# b: 1 x 2 x 1
# c: 4 x 1 x 1
```

Как вы теперь знаете, с такими массивами можно выполнять любые поэлементные операции. Поменяем размерности:

```python
a.shape = 1, 1, -1
b.shape = 1, -1, 1
c.shape = -1, 1, 1
```

И теперь, можем спокойно выполнить искомое действие:

```python
a * b + c # массив 4x2x3
```

Фактически, мы здесь получили все возможные варианты перемножений вектора a на числа 4 и 5 и сложений с числами 7, 8, 9 и 10. Для этого было достаточно к одномерным массивам добавить соответствующие оси. Так вот, эту операцию можно автоматизировать с помощью функции ix_(), следующим образом:

```python
a = np.array([1, 2, 3])
b = np.array([4, 5])
c = np.array([7, 8, 9, 10])
an, bn, cn = np.ix_(a, b, c)
```

На выходе имеем массивы an, bn и cn с нужным расположением и числом осей. И, далее, осталось только выполнить математическое действие:

```python
an * bn + cn # массив 3x2x4
```

Единственным ограничением этой функции является ее применимость только к одномерным массивам. С многомерными она не работает и приводит к ошибке.