21.04.2023    23:12
Теги: #Python 
---
# ***Внутренние ссылки:***
[[Форматирование строк, f-строки]]
---
# ***Внешние ссылки:***

---
# ***Заметка:***

# Таблица "Функции и методы строк"

**S = 'str'; S = "str"; S = '''str'''; S = """str"""**

**S1 + S2** Конкатенация (сложение строк)

**S1 * 3** Повторение строки

**S[i]** Обращение по индексу

**S[i:j:step]** Извлечение среза

**len**(S) Длина строки

**S.find**(str, [start],[end]) Поиск подстроки в строке. Возвращает номер первого вхождения или -1

**S.rfind**(str, [start],[end]) Поиск подстроки в строке. Возвращает номер последнего вхождения или -1

**S.index**(str, [start],[end]) Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError

**S.rindex**(str, [start],[end]) Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError

**S.replace**(шаблон, замена) Замена шаблона

**S.split**(символ) Разбиение строки по разделителю

**S.isdigit**() Состоит ли строка из цифр

**S.isalpha**() Состоит ли строка из букв

**S.isalnum**() Состоит ли строка из цифр или букв

**S.islower**() Состоит ли строка из символов в нижнем регистре

**S.isupper**() Состоит ли строка из символов в верхнем регистре

**S.isspace**() Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))

**S.istitle**() Начинаются ли слова в строке с заглавной буквы

**S.upper**() Преобразование строки к верхнему регистру

**S.lower**() Преобразование строки к нижнему регистру

**S.startswith**(str) Начинается ли строка S с шаблона str

**S.endswith**(str) Заканчивается ли строка S шаблоном str

**S.join**(список) Сборка строки из списка с разделителем S

**ord**(символ) Символ в его код ASCII

**chr**(число) Код ASCII в символ

**S.capitalize**() Переводит первый символ строки в верхний регистр, а все остальные в нижний

**S.center**(width, [fill]) Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)

**S.count**(str, [start],[end]) Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)

**S.expandtabs**([tabsize]) Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам

**S.lstrip**([chars]) Удаление пробельных символов в начале строки

**S.rstrip**([chars]) Удаление пробельных символов в конце строки

**S.strip**([chars]) Удаление пробельных символов в начале и в конце строки

**S.partition**(шаблон) Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки

**S.rpartition**(sep) Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку

**S.swapcase**() Переводит символы нижнего регистра в верхний, а верхнего – в нижний

**S.title**() Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

**S.zfill**(width) Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями

**S.ljust**(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar

**S.rjust**(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar


# Методы и функции

Мы уже знакомы с некоторыми встроенными функциями: `min()`,`max()`,`len()`,`int()`,`float()` и т.д. Метод — специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения.

Таким образом: метод — функция, применяемая к объекту. В данном случае к строке. Метод вызывается в виде `имя_объекта.имя_метода(параметры)`.

Например, `s.find('e')` — это применение к строке `s` метода `find` с одним параметром `'e'`.

Методы строкового типа данных можно разделить на три группы:

1.  **Конвертация регистра;**
2.  Поиск и замена;
3.  Классификация символов.

## Конвертация регистра

Методы в этой группе выполняют преобразование регистра для строк.

### Метод capitalize()

Метод `capitalize()` возвращает копию строки `s`, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.

```python
s = 'foO BaR BAZ quX'
print(s.capitalize())
```

```no-highlight
Foo bar baz qux
```

Символы, не являющиеся буквами алфавита, остаются неизменными. Результатом выполнения следующего кода:

```python
s = 'foo123#BAR#.'
print(s.capitalize())
```

```no-highlight
Foo123#bar#.
```

### Метод swapcase()

Метод `swapcase()` возвращает копию строки `s`, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.

```python
s = 'FOO Bar 123 baz qUX'
print(s.swapcase())
```

```no-highlight
foo bAR 123 BAZ Qux
```

### Метод title()

Метод `title()` возвращает копию строки `s`, в которой первый символ каждого слова переводится в верхний регистр.

```python
s = 'the sun also rises'
print(s.title())
```

```no-highlight
The Sun Also Rises
```

Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы. 
```python
s = "what's happened to ted's IBM stock?"
print(s.title())
```

```no-highlight
What'S Happened To Ted'S Ibm Stock?
```

###  Метод lower()

Метод `lower()` возвращает копию строки `s`, в которой все символы имеют нижний регистр.

```python
s = 'FOO Bar 123 baz qUX'
print(s.lower())
```

```no-highlight
foo bar 123 baz qux
```

### Метод upper()

Метод `upper()` возвращает копию строки `s`, в которой все символы имеют верхний регистр.

```python
s = 'FOO Bar 123 baz qUX'
print(s.upper())
```

```no-highlight
FOO BAR 123 BAZ QUX
```

Одно очень важное замечание о методах данной категории состоит в том, что они не изменяют исходную строку. Если вы хотите изменить строку `s` нужно написать код: `s = s.lower()`.

## Поиск и замена

Методы поиска и замены строк внутри других строк.

Каждый метод в этой группе поддерживает необязательные аргументы `<start>` и `<end>`. Как и в строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции символа `<start>` и продолжающейся вплоть до позиции символа `<end>`, но не включающей ее. Если параметр `<start>` указан, а параметр `<end>` нет, то метод применяется к части исходной строки от `<start>` до конца строки. Если параметры не заданы, то подразумевается, что `<start> = 0 , <end> = len(s)`.

### Метод count()

Метод `count(<sub>, <start>, <end>)` считает количество **непересекающихся** вхождений подстроки `<sub>` в исходную строку `s`.

Результатом выполнения следующего кода:

```python
s = 'foo goo moo'
print(s.count('oo'))
print(s.count('oo', 0, 8))  # подсчет с 0 по 7 символ
```

```no-highlight
3
2
```

### Метод startswith()

Метод `startswith(<suffix>, <start>, <end>)` определяет **начинается** ли исходная строка `s` подстрокой `<suffix>`. Если исходная строка начинается с подстроки suffix,метод возвращает значение True, а если нет, то  False.

Результатом выполнения следующего кода:

```python
s = 'foobar'
print(s.startswith('foo'))
print(s.startswith('baz'))
```


```no-highlight
True
False
```

### Метод endswith()

Метод `endswith(<suffix>, <start>, <end>)` определяет **оканчивается** ли исходная строка `s` подстрокой `<suffix>`. Метод возвращает значение `True` если исходная строка оканчивается на подстроку `<suffix>` и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s = 'foobar'
print(s.endswith('bar'))
print(s.endswith('baz'))
```

```no-highlight
True
False
```

### Методы find(), rfind()

Метод `find(<sub>, <start>, <end>)` находит **индекс первого вхождения** подстроки `<sub>` в исходной строке `s`. Если строка `s` не содержит подстроки `<sub>`, то метод возвращает значение `-1`. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.

```python
s = 'foo bar foo baz foo qux'
print(s.find('foo'))
print(s.find('bar'))
print(s.find('qu'))
print(s.find('python'))
```

```no-highlight
0
4
20
-1
```

Метод `rfind(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>` начиная с конца строки `s`.

### Методы index(), rindex()

Метод `index(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он **вызывает ошибку**  `ValueError: substring not found` во время выполнения программы, если подстрока `<sub>` не найдена.

Метод `rindex(<sub>, <start>, <end>)` идентичен методу `index(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>` начиная с конца строки `s`.

Методы `find()` и `rfind()` являются более безопасными чем `index()` и `rindex()`, так как не приводят к возникновению ошибки во время выполнения программы.

### Метод strip()

Метод `strip()` возвращает копию строки `s` у которой удалены все пробелы стоящие **в начале и конце** строки.

```python
s = '     foo bar foo baz foo qux      '
print(s.strip())
```

```no-highlight
foo bar foo baz foo qux
```

### Метод lstrip()

Метод `lstrip()` возвращает копию строки `s` у которой удалены все пробелы стоящие **в начале** строки.

```python
s = '     foo bar foo baz foo qux      '
print(s.lstrip())
```


```no-highlight
foo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵
```

### Метод rstrip()

Метод `rstrip()` возвращает копию строки `s` у которой удалены все пробелы стоящие **в конце** строки.

```python
s = '      foo bar foo baz foo qux      '
print(s.rstrip())
```


```no-highlight
⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux
```

Методы `strip(), lstrip(), rstrip()` могут принимать на вход опциональный аргумент`<chars>`. Необязательный аргумент `<chars>`– это строка, которая определяет набор символов для удаления.

### Метод replace()

Метод `replace(<old>, <new>)` возвращает копию `s` **со всеми** вхождениями подстроки `<old>`, замененными на `<new>`.

```python
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault'))
```

```no-highlight
grault bar grault baz grault qux
```

Метод `replace()` может принимать опциональный третий аргумент `<count>`,  который определяет количество замен.

```python
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault', 2))
```

```no-highlight
grault bar grault baz foo qux
```

## Классификация символов

Методы в этой группе классифицируют строку на основе содержащихся в ней символов.

### Метод isalnum()

Метод `isalnum()` определяет, состоит ли исходная строка из буквенно-цифровых символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенно-цифровых символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = 'abc123'
s2 = 'abc$*123'
s3 = ''

print(s1.isalnum())
print(s2.isalnum())
print(s3.isalnum())
```

будет:

```no-highlight
True
False
False
```

### Метод isalpha()

Метод `isalpha()` определяет, состоит ли исходная строка из буквенных символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенных символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = 'ABCabc'
s2 = 'abc123'
s3 = ''

print(s1.isalpha())
print(s2.isalpha())
print(s3.isalpha())
```

будет:

```no-highlight
True
False
False
```

### Метод isdigit()

Метод `isdigit()` определяет, состоит ли исходная строка **только** из цифровых символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из цифровых символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = '1234567'
s2 = 'abc123'
s3 = ''

print(s1.isdigit())
print(s2.isdigit())
print(s3.isdigit())
```

будет:

```no-highlight
True
False
False
```

### Метод islower()

Метод `islower()` определяет, являются ли **все** буквенные символы исходной строки строчными (имеют нижний регистр). Метод возвращает значение `True` если все буквенные символы исходной строки являются строчными и `False` в противном случае. **Все неалфавитные символы игнорируются!**

Результатом выполнения следующего кода:

```python
s1 = 'abc'
s2 = 'abc1$d'
s3 = 'Abc1$D'

print(s1.islower())
print(s2.islower())
print(s3.islower())
```

будет:

```no-highlight
True
True
False
```

### Метод isupper()

Метод `isupper()` определяет, являются ли **все** буквенные символы исходной строки заглавными (имеют верхний регистр). Метод возвращает значение `True` если все буквенные символы исходной строки являются заглавными и `False` в противном случае. **Все неалфавитные символы игнорируются!**

Результатом выполнения следующего кода:

```python
s1 = 'ABC'
s2 = 'ABC1$D'
s3 = 'Abc1$D'

print(s1.isupper())
print(s2.isupper())
print(s3.isupper())
```

будет:

```no-highlight
True
True
False
```

### Метод isspace()

Метод `isspace()` определяет, состоит ли исходная строка **только** из пробельных символов. Метод возвращает значение `True` если строка состоит только из пробельных символов и `False` в противном случае.

Результатом выполнения следующего кода:

```python
s1 = '       '
s2 = 'abc1$d'

print(s1.isspace())
print(s2.isspace())
```

будет:

```no-highlight
True
False
```

## Метод split()

Метод `split()` разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов.

Следующий программный код:

```python
s = 'Python is the most powerful language'
words = s.split()
print(words)
```

```no-highlight
['Python', 'is', 'the', 'most', 'powerful', 'language']
```

![[Pasted image 20230426160523.png]]

Таким образом, вызов метода `split()` разбивает строку на слова и возвращает список, содержащий все слова.

Рассмотрим следующий программный код:

```python
numbers = input().split()
```

Если при запуске этой программы ввести строку `1 2 3 4 5`, то список `numbers` будет следующим  `['1', '2', '3', '4', '5']`. Обратите внимание, что список будет состоять из строк, а не из чисел. Если требуется получить именно список чисел, то затем нужно элементы списка по одному преобразовать в числа:

```python
numbers = input().split()
for i in range(len(numbers)):
    numbers[i] = int(numbers[i])
```

Необязательный параметр

У метода `split()` есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. Например, вызов метода `split('.')` вернет список, полученный разделением исходной строки по символу `'.'`.

Следующий программный код:

```python
ip = '192.168.1.24'
numbers = ip.split('.')    # указываем явно разделитель
print(numbers)
```

выведет список:

```no-highlight
['192', '168', '1', '24']
```

![[Pasted image 20230426161116.png]]

## Метод join()

Метод `join()` собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.

 Следующий программный код:

```python
words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)
print(s)
```

выведет: 

```no-highlight
Python is the most powerful language
```

![[Pasted image 20230426161138.png]]

Обратите внимание, все слова разделены одним пробелом, поскольку метод `join()` вызывался на строке состоящей из одного символа пробела `' '`.

Рассмотрим еще пару примеров:

```python
words = ['Мы', 'учим', 'язык', 'Python']
print('*'.join(words))
print('-'.join(words))
print('?'.join(words))
print('!'.join(words))
print('*****'.join(words))
print('abc'.join(words))
print('123'.join(words))
```

Результатом выполнения такого кода будет:

```no-highlight
Мы*учим*язык*Python
Мы-учим-язык-Python
Мы?учим?язык?Python
Мы!учим!язык!Python
Мы*****учим*****язык*****Python
МыabcучимabcязыкabcPython
Мы123учим123язык123Python
```

Запомни:** Строковый метод `split()` служит для преобразования строки в список, а метод `join()` — для преобразования списка в строку.

## Примечания split() join()

**Примечание 1.** Существует большая разница между результатами вызова методов `s.split()` и `s.split(' ')`. Разница в поведении проявляется когда строка содержит несколько пробелов между словами.

Следующий программный код:

```python
s = 'Python    is   the  most  powerful  language'
words1 = s.split()
words2 = s.split(' ')
print(words1)
print(words2)
```

 выведет списки:

```no-highlight
['Python', 'is', 'the', 'most', 'powerful', 'language']
['Python', '', '', '', 'is', '', '', 'the', '', 'most', '', 'powerful', '', 'language']
```

**Примечание 2.** Методы `split()` и `join()` являются строковыми методами. Следующий код приводит к ошибке:

```python
print([1, 2].split())
print([1, 2].join([3, 4, 5]))
```

**Примечание 3.** Строковый метод `join()` работает только со списком строк. Следующий код приводит к ошибке:

```python
numbers = [1, 2, 3, 4]  # список чисел
s = '*'.join(numbers)
print(s)
```

## Метод ljust()

Строковый метод `ljust()` выравнивает текст по ширине, **добавляя пробелы** в конец текста.

Результатом выполнения следующего кода:

```python
print('a'.ljust(3))
print('ab'.ljust(3))
print('abc'.ljust(3))
```

будет:

```no-highlight
a⎵⎵
ab⎵
abc
```

Исходная строка не обрезается, даже если в ней больше символов, чем нужно.

Результатом выполнения следующего кода:

```python
print('abcdefg'.ljust(3))
```

будет:

```no-highlight
abcdefg
```

Строковый метод `ljust()` использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.

Результатом выполнения следующего кода:

```python
print('a'.ljust(5, '*'))
print('ab'.ljust(5, '$'))
print('abc'.ljust(5, '#'))
```

будет:

```no-highlight
a****
ab$$$
abc##
```

## Метод rjust()

Строковый метод `rjust()` выравнивает текст по ширине, **добавляя пробелы** в начало текста.

Результатом выполнения следующего кода:

```python
print('a'.rjust(3))
print('ab'.rjust(3))
print('abc'.rjust(3))
```

будет:

```no-highlight
⎵⎵a
⎵ab
abc
```

Исходная строка не обрезается, даже если в ней больше символов, чем нужно.

Результатом выполнения следующего кода:

```python
print('abcdefg'.rjust(3))
```

будет:

```no-highlight
abcdefg
```

Строковый метод `rjust()` использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.

Результатом выполнения следующего кода:

```python
print('a'.rjust(5, '*'))
print('ab'.rjust(5, '$'))
print('abc'.rjust(5, '#'))
```

будет:

```no-highlight
****a
$$$ab
##abc
```

Применив метод `ljust()` для выравнивания столбцов при выводе таблицы мы получим следующий код:

```python
rows, cols = 3, 4                # rows - количество строк, cols - количество столбцов

matrix  = [[277, -930, 11, 0],
           [9, 43, 6, 87],
           [4456, 8, 290, 7]]

for r in range(rows):
    for c in range(cols):
        print(str(matrix[r][c]).ljust(6), end='')
    print()
